#+TITLE: Razor File Manager - Click Handling Documentation
#+AUTHOR: Generated from codebase analysis
#+DATE: 2025-12-01
#+OPTIONS: toc:3 num:t

* DEBUGGING NOTES: Background Right-Click Issue (2025-12-01)

** Problem
Background right-click on the white file list area (empty space below files) does not show context menu.
This regressed after shift-click/multi-select features were added.

** Debug Findings
1. Added debug logging to bgRightClickTag event handler (layout.go:1290)
2. Added debug logging to bgClick event handler (layout.go:84-91)
3. *CRITICAL*: Neither handler is receiving pointer.Press events for right-clicks!
4. BUT: Row right-clicks DO work (rowRightClicked=true was observed)

** Event Handler Registration

| Handler         | File                  | Line | Target              | Uses PassOp |
|-----------------+-----------------------+------+---------------------+-------------|
| Global mouse    | layout.go             | 40-44| &r.mouseTag         | YES         |
| bgClick         | layout.go             | 97-99| &r.bgClick          | NO          |
| bgRightClickTag | layout.go             | 1283 | &r.bgRightClickTag  | NO          |
| Row right-click | renderer.go           | 1521 | &item.RightClickTag | NO          |

** Hypothesis
The file list's internal layout (layout.List) may be creating its own clip areas that
exclude the empty space below the rendered rows. The bgRightClickTag is registered
with clip covering the FULL area (gtx.Constraints.Max), but events may not be
delivered because Gio's event routing depends on the clip stack at render time.

** Key Code Sections
- Background right-click handler: layout.go:1278-1425
- Row right-click handler: renderer.go:1447-1456, 1520-1521
- Global mouse tracking: layout.go:37-58

** Solution Implemented
Moved right-click detection to the global mouse position tracker (layout.go:46-77)
which uses PassOp and receives ALL pointer events.

Added fields:
- renderer.go:563: fileListSize image.Point
- layout.go:1254-1255: Set r.fileListSize at start of layoutFileList

Debug output confirmed events ARE being received:
#+BEGIN_EXAMPLE
15:41:44.096925 [UI] Global mouse press: pos=(143,630), buttons=ButtonSecondary
15:41:44.096946 [UI] Right-click detected: mousePos=(143,630), fileListBounds=(362,184)-(1600,1252), inBounds=false
#+END_EXAMPLE

** Current Issue
Click at X=143 is IN THE SIDEBAR (sidebar is ~180dp wide, starts at X=0).
The file list starts at X=362 (after sidebar + divider).
Need to test clicking on empty space in the ACTUAL file list area (to the right of sidebar).

** Layout Coordinates Reference
- Sidebar: X=0 to X~180dp
- Divider: X~180 to X~181dp
- File list: X~181dp to window edge (or preview pane)
- Header area: Y=0 to Y~92dp (File button + navbar)
- File list content: Y~92dp onwards

** Fix: Simplified Background Right-Click Detection (2025-12-01)

*** Problem Identified
The right-click bounds checking in the global mouse handler was using hardcoded pixel offsets
and complex bounds calculations that didn't work reliably across different screen positions.

Original approach tried to calculate file list bounds using:
- ~sidebarWidth := gtx.Dp(181)~ (sidebar + divider)
- ~headerHeight := gtx.Dp(92)~ (approximation of File button + navbar + insets)

This failed because:
1. Coordinate systems in Gio are complex with transformations at each layout level
2. The bounds detection was inconsistent - clicks would only register ~1/4 of the way across the empty space
3. Dynamic elements (tab bar, config banner) change the offsets unpredictably

*** Key Insight
The global mouse handler uses ~pointer.PassOp{}~ which means it only receives events that
*weren't consumed* by other handlers. Since:
- File rows have their own right-click handlers
- Sidebar favorites have their own right-click handlers
- Buttons and other UI elements consume their own events

Any right-click that reaches the global handler is, by definition, on "empty" background space.

*** Solution Implemented
*Removed all bounds checking* - simply treat any right-click reaching the global handler as a background click:

#+BEGIN_SRC go
// Before: Complex bounds checking that didn't work
if e.Buttons.Contain(pointer.ButtonSecondary) {
    fileListBounds := image.Rectangle{...}
    if r.mousePos.In(fileListBounds) {
        r.bgRightClickPending = true
    }
}

// After: Trust that PassOp filters to only unhandled clicks
if e.Buttons.Contain(pointer.ButtonSecondary) {
    r.bgRightClickPending = true
    r.bgRightClickPos = r.mousePos
}
#+END_SRC

*** Why This Works
- Gio's event system with ~PassOp~ naturally filters events
- Events consumed by specific handlers (rows, sidebar, etc.) don't reach the global handler
- Only "orphan" clicks on empty space pass through
- This is more robust than trying to calculate exact pixel bounds

*** How PassOp Event Filtering Works

**** Gio's Event Routing Model
Gio uses a clip-based event routing system. When a pointer event occurs:
1. Gio traverses the clip stack from front to back (top to bottom in z-order)
2. Each clip area with a registered event handler gets a chance to receive the event
3. By default, once an event is delivered to a handler, it is *consumed* and not passed further

**** The PassOp Mechanism
~pointer.PassOp{}~ changes this behavior. When pushed onto the ops stack:
- Events are still delivered to the handler
- But they are also *passed through* to handlers underneath
- This allows a "catch-all" handler that observes events without blocking them

**** Current Event Handler Hierarchy (Z-Order)

| Priority | Handler                | Location              | PassOp | Consumes Right-Click |
|----------+------------------------+-----------------------+--------+----------------------|
| 1 (top)  | Global mouse tracker   | layout.go:40-44       | YES    | NO (observes only)   |
| 2        | File row clickables    | renderer.go:1519-1523 | NO     | YES                  |
| 3        | Favorite row clickables| renderer.go:1642-1650 | NO     | YES                  |
| 4        | Sidebar buttons        | various               | NO     | YES (left-click)     |
| 5        | bgClick (left-click)   | layout.go:113-128     | NO     | YES (left-click)     |
| 6        | bgRightClickTag        | layout.go:1314-1316   | NO     | YES                  |

**** Event Flow for Right-Clicks

***** Scenario 1: Right-click on a file row
#+BEGIN_EXAMPLE
1. Global mouse tracker receives event (PassOp=YES)
   -> Records mousePos, sets lastClickModifiers
   -> Sets bgRightClickPending = true (tentatively)
   -> Event passes through

2. File row handler receives event (PassOp=NO)
   -> Detects ButtonSecondary
   -> Sets rowRightClicked = true
   -> Shows context menu for that file
   -> Event consumed (stops here)

3. After row processing in layoutFileList:
   -> Checks: if bgRightClickPending && !rowRightClicked
   -> Since rowRightClicked=true, bgRightClickPending is cleared
   -> No background menu shown
#+END_EXAMPLE

***** Scenario 2: Right-click on empty space (background)
#+BEGIN_EXAMPLE
1. Global mouse tracker receives event (PassOp=YES)
   -> Records mousePos, sets lastClickModifiers
   -> Sets bgRightClickPending = true
   -> Event passes through

2. No file row handler exists at click position
   -> Event continues to bgRightClickTag handler

3. bgRightClickTag handler in layoutFileList
   -> Also sets bgRightClickPending = true (redundant but safe)

4. After row processing in layoutFileList:
   -> Checks: if bgRightClickPending && !rowRightClicked
   -> Since rowRightClicked=false, shows background context menu
   -> Menu shows: New File, New Folder, Paste
#+END_EXAMPLE

***** Scenario 3: Right-click on sidebar favorite
#+BEGIN_EXAMPLE
1. Global mouse tracker receives event (PassOp=YES)
   -> Records mousePos
   -> Sets bgRightClickPending = true (tentatively)
   -> Event passes through

2. Favorite row handler receives event (PassOp=NO)
   -> Detects ButtonSecondary
   -> Shows context menu for that favorite
   -> Event consumed (stops here)

3. layoutFileList never sees this event
   -> bgRightClickPending from global handler is stale
   -> But favorite's menu is already shown, so it works correctly
#+END_EXAMPLE

**** The Pending Flag Pattern

The ~bgRightClickPending~ flag serves as a coordination mechanism:

#+BEGIN_SRC go
// Set tentatively by global handler (for ALL right-clicks)
r.bgRightClickPending = true
r.bgRightClickPos = r.mousePos

// Cleared/used after processing all rows
if r.bgRightClickPending && !rowRightClicked {
    // This was truly a background click
    r.menuVisible = true
    r.menuIsBackground = true
    // ... show background menu
}
r.bgRightClickPending = false
#+END_SRC

This pattern allows:
1. Global handler to optimistically mark potential background clicks
2. Row handlers to claim clicks on actual items
3. Final decision made after all rows processed

**** Why Bounds Checking Was Unnecessary

The previous implementation tried to filter right-clicks by checking if mousePos
was within calculated file list bounds. This was:

1. *Redundant*: Events outside the file list area are already handled by their
   respective handlers (sidebar, navbar, etc.) and never reach the background handler

2. *Error-prone*: Calculating exact bounds requires tracking accumulated offsets
   through multiple nested layout containers, which is fragile

3. *Over-complicated*: The PassOp + pending flag pattern already provides the
   filtering we need - if an event reaches the background check without being
   claimed by a row, it's by definition a background click

**** Current Implementation (layout.go:46-68)

#+BEGIN_SRC go
// Global mouse tracker with PassOp
areaStack := clip.Rect{Max: gtx.Constraints.Max}.Push(gtx.Ops)
passOp := pointer.PassOp{}.Push(gtx.Ops)
event.Op(gtx.Ops, &r.mouseTag)
passOp.Pop()
areaStack.Pop()

// Process events - no bounds checking needed
for {
    ev, ok := gtx.Event(pointer.Filter{Target: &r.mouseTag, Kinds: pointer.Move | pointer.Press})
    if !ok {
        break
    }
    if e, ok := ev.(pointer.Event); ok {
        r.mousePos = image.Pt(int(e.Position.X), int(e.Position.Y))
        if e.Kind == pointer.Press {
            r.lastClickModifiers = e.Modifiers

            // Any right-click reaching here that isn't claimed by a row
            // is a background click - trust the event routing
            if e.Buttons.Contain(pointer.ButtonSecondary) {
                r.bgRightClickPending = true
                r.bgRightClickPos = r.mousePos
            }
        }
    }
}
#+END_SRC

* Overview

This document details how left and right mouse clicks are handled in the Razor file manager, both at a global level and for specific UI objects. The application is built using the Gio UI framework for Go.

* Global Click Handling

** Main Event Loop
:PROPERTIES:
:FILE: internal/app/orchestrator.go
:LINES: 238-256
:END:

The central Gio event loop processes ~app.FrameEvent~ for each frame:
1. Calls ~ui.Layout(gtx, &state)~ which returns a ~UIEvent~
2. Passes the returned ~UIEvent~ to ~handleUIEvent()~ for processing

All click events eventually flow through this loop and result in a ~UIEvent~ being dispatched.

** Global Mouse Position Tracking
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 37-58
:END:

A global mouse position tracker captures:
- Mouse position stored in ~r.mousePos~ (image.Point)
- Modifier keys at click time in ~r.lastClickModifiers~ (key.Modifiers)

#+BEGIN_SRC go
pointer.Filter{Kinds: pointer.Move | pointer.Press}
#+END_SRC

This is used for:
- Positioning context menus accurately
- Detecting modifier key combinations (Shift, Ctrl, Cmd)

** Background Click Dismissal
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 82-99
:END:

A ~bgClick~ widget listens for clicks anywhere on the window background. When triggered, ~onLeftClick()~ is called which:
- Dismisses context menu (~r.menuVisible = false~)
- Dismisses file menu (~r.fileMenuOpen = false~)
- Exits path edit mode (~r.isEditing = false~)

* File and Folder Click Handling

** File List Click Detection
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1253-1426
:END:

*** Left-Click Processing (Lines 1362-1404)

**** Single Click
- Creates ~UIEvent{Action: ActionSelect, NewIndex: i}~
- Updates ~r.lastClickIndex~ and ~r.lastClickTime~ for double-click detection
- Exits multi-select mode
- Triggers preview pane for files

**** Double-Click
- Detected when same item clicked within ~doubleClickInterval~ (200ms)
- On directories: navigates into the directory
- On files: opens the file with default application
- Exits multi-select mode
- Resets click tracking

#+BEGIN_SRC go
isDoubleClick := r.lastClickIndex == i &&
    !r.lastClickTime.IsZero() &&
    now.Sub(r.lastClickTime) < doubleClickInterval
#+END_SRC

**** Shift+Click
:PROPERTIES:
:LINES: 1385-1396
:END:

Modifier detection at line 1436:
#+BEGIN_SRC go
shiftHeld := r.lastClickModifiers.Contain(key.ModShift)
#+END_SRC

| Condition | Action |
|-----------+--------|
| First Shift+Click | Enters multi-select mode with ~ActionToggleSelect~ |
| Subsequent Shift+Clicks | Toggles individual items in selection |

*** Right-Click Processing (Lines 1348-1359)

Detection via:
#+BEGIN_SRC go
pointer.Filter{Target: &item.RightClickTag, Kinds: pointer.Press}
// Check for: e.Buttons.Contain(pointer.ButtonSecondary)
#+END_SRC

Actions:
- Sets ~r.menuVisible = true~
- Stores context: ~r.menuPath~, ~r.menuIsDir~, ~r.menuIsFav~
- Does NOT change selection (menu uses ~collectSelectedPaths()~ for operations)

*** Background Click Handling
:PROPERTIES:
:LINES: 1279-1420
:END:

Separate handler for the entire file list area using ~&r.bgRightClickTag~:

| Click Type | Action |
|------------+--------|
| Left-click on empty space | Clears selection |
| Right-click on empty space | Shows background context menu (New File, New Folder, Paste) |

Uses a "pending" pattern (~bgRightClickPending~ flag) to distinguish row clicks from background clicks.

*** Checkbox Toggle (Lines 1337-1340)

Checkboxes are only visible in multi-select mode:
#+BEGIN_SRC go
showCheckbox := r.multiSelectMode
#+END_SRC

Checkbox click triggers ~ActionToggleSelect~ event.

* Button and UI Element Click Handling

** Navigation Buttons
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 225-241
:END:

| Button | Detection | Action |
|--------+-----------+--------|
| Back | ~r.backBtn.Clicked(gtx)~ | ~ActionBack~ |
| Forward | ~r.fwdBtn.Clicked(gtx)~ | ~ActionForward~ |
| Home | ~r.homeBtn.Clicked(gtx)~ | ~ActionHome~ |

All navigation buttons:
1. Call ~r.onLeftClick()~ to dismiss menus
2. Call ~gtx.Execute(key.FocusCmd{Tag: keyTag})~ to return keyboard focus

** Breadcrumb Navigation
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 264-305
:END:

| Action | Effect |
|--------+--------|
| Single-click on segment | Navigates to that path |
| Double-click on segment | Enters path edit mode |

Click tracking via ~r.breadcrumbBtns[i]~ and ~r.breadcrumbLastClicks[i]~.

** Search Box
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 309-450
:END:

| Event | Action |
|-------+--------|
| ~SubmitEvent~ | Execute search |
| ~ChangeEvent~ | Update search suggestions |
| ~SelectEvent~ | Handle selection |
| Clear button (~r.searchClearBtn.Clicked(gtx)~) | ~ActionClearSearch~ |

Search history items are clickable buttons in dropdown.

** Column Headers
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1396-1404 (in renderColumns)
:END:

Each column has ~r.headerBtns[i]~. Click toggles sort column and direction, generating ~ActionSort~ event.

** Browser Tabs
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1618-1627
:END:

| Widget | Action |
|--------+--------|
| ~r.browserTabs[i].tabBtn.Clicked(gtx)~ | ~ActionSwitchTab~ |
| ~r.browserTabs[i].closeBtn.Clicked(gtx)~ | ~ActionCloseTab~ |

** File Menu
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1761-1804
:END:

- Top-level "File" button toggles menu visibility
- Menu items generate: ~NewWindow~, ~NewTab~, ~Settings~, etc.

** Dialog Buttons

All dialogs (Create, Delete, Conflict) use standard button click detection and call ~onLeftClick()~ before processing action.

* Context Menu Handling

** Visibility and Positioning
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1806-1901
:END:

Menu shows when ~r.menuVisible = true~ with context:
| Field | Purpose |
|-------+---------|
| ~r.menuPos~ | Position (from global mouse tracker) |
| ~r.menuPath~ | Target file/directory path |
| ~r.menuIsDir~ | Whether target is directory |
| ~r.menuIsFav~ | Whether path is in favorites |
| ~r.menuIsBackground~ | Whether clicked on empty space |

** Position Calculation (Lines 1819-1839)

- Menu width: 180dp
- Flips horizontally if would go off right edge
- Flips vertically if would go off bottom edge
- Clamps to window edges as fallback

** Menu Items by Context

*** For Files
| Menu Item | Action |
|-----------+--------|
| Open | ~ActionOpen~ |
| Open With... | ~ActionOpenWith~ |
| Copy | ~ActionCopy~ (uses ~collectSelectedPaths()~) |
| Cut | ~ActionCut~ |
| Paste | ~ActionPaste~ |
| Delete | ~ActionConfirmDelete~ |
| Rename | Triggers inline rename UI |

*** For Directories
All file options plus:
| Menu Item | Action |
|-----------+--------|
| Open in New Tab | ~ActionOpenInNewTab~ |
| Add/Remove Favorite | ~ActionAddFavorite~ / ~ActionRemoveFavorite~ |

*** For Empty Space (Background)
| Menu Item | Action |
|-----------+--------|
| New File | Shows create dialog |
| New Folder | Shows create dialog |
| Paste | ~ActionPaste~ (if clipboard has content) |

All menu clicks call ~r.onLeftClick()~ which dismisses the menu before executing action.

* Selection System

** Single Selection
:PROPERTIES:
:FILE: internal/app/orchestrator.go
:LINES: 316-329
:END:

~ActionSelect~:
- Sets ~o.state.SelectedIndex = evt.NewIndex~
- Clears ~SelectedIndices~ map
- Shows/hides preview based on file type

** Multi-Select Mode
:PROPERTIES:
:FILE: internal/app/orchestrator.go
:LINES: 330-378
:END:

| Trigger | Shift+Click |
| Storage | ~o.state.SelectedIndices~ map[int]bool |
| Toggle | ~ActionToggleSelect~ toggles items in/out |
| UI | Shows checkboxes when active |
| Preview | Hidden when 2+ items selected |

~OldIndex~ field used to include previous selection on first Shift+Click.

** Range Select
:PROPERTIES:
:LINES: 379-393
:END:

~ActionRangeSelect~ (for Shift+Click range selection):
- Selects all items between OldIndex and NewIndex
- Intended for keyboard navigation extensions

** Clear Selection
:PROPERTIES:
:LINES: 394-398
:END:

Background click or Escape:
- Clears ~SelectedIndex~ and ~SelectedIndices~
- Hides preview pane

** Multi-Select Path Collection
:PROPERTIES:
:FILE: internal/app/orchestrator.go
:LINES: 1145-1168
:END:

~collectSelectedPaths()~ used by context menu and keyboard shortcuts:
1. Returns all paths in ~SelectedIndices~ if multi-select active
2. Falls back to single selected item
3. Falls back to menu target path

* Modifier Key Handling

** Global Modifier Tracking
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 37-58
:END:

Captured at pointer Press event:
#+BEGIN_SRC go
r.lastClickModifiers = e.Modifiers
#+END_SRC

** Shift Key

| Context | Effect |
|---------+--------|
| File List | Shift+Click toggles multi-select (lines 1385-1396) |
| Keyboard | Shift+Ctrl+N creates folder vs. file |

** Ctrl/Cmd Key

| Shortcut | Action |
|----------+--------|
| Ctrl+C | Copy (lines 1340-1344) |
| Ctrl+X | Cut (lines 1345-1349) |
| Ctrl+V | Paste (lines 1350-1353) |
| Ctrl+N | Create file |
| Ctrl+Shift+N | Create folder (lines 1354-1361) |

** Keyboard Shortcuts
:PROPERTIES:
:FILE: internal/ui/renderer.go
:LINES: 1285-1375
:END:

All modifier checks use:
#+BEGIN_SRC go
k.Modifiers.Contain(key.ModCtrl)
#+END_SRC

| Key | Action |
|-----+--------|
| Arrow keys | Navigate selection up/down/sideways |
| Enter/Return | Open/navigate to selection |
| Delete | Open delete confirmation for selected items |
| Escape | Dismiss preview pane, cancel rename |

* Click-Related State Management

** Renderer Fields
:PROPERTIES:
:FILE: internal/ui/renderer.go
:LINES: 505-667
:END:

*** Click Tracking
| Field | Type | Purpose |
|-------+------+---------|
| ~lastClickIndex~ | int | Index of last clicked item |
| ~lastClickTime~ | time.Time | Time for double-click detection |
| ~lastClickModifiers~ | key.Modifiers | Modifiers held during last click |
| ~multiSelectMode~ | bool | Whether checkboxes visible |

*** Context Menu State
| Field | Type | Purpose |
|-------+------+---------|
| ~menuVisible~ | bool | Menu is shown |
| ~menuPos~ | image.Point | Menu position (from mouse) |
| ~menuPath~ | string | Target path |
| ~menuIsDir~ | bool | Target is directory |
| ~menuIsFav~ | bool | Target is favorite |
| ~menuIsBackground~ | bool | Clicked on empty space |

*** Background Right-Click
| Field | Type | Purpose |
|-------+------+---------|
| ~bgRightClickPending~ | bool | Right-click detected, waiting for row |
| ~bgRightClickPos~ | image.Point | Position of background right-click |
| ~bgRightClickTag~ | struct{} | Event tag for background area |

*** UI State
| Field | Type | Purpose |
|-------+------+---------|
| ~isEditing~ | bool | Path bar in edit mode |
| ~multiSelectMode~ | bool | Multi-select mode active |
| ~fileMenuOpen~ | bool | File menu dropdown visible |
| ~searchHistoryVisible~ | bool | Search history dropdown visible |
| ~settingsOpen~ | bool | Settings modal visible |
| ~deleteConfirmOpen~ | bool | Delete confirmation dialog visible |
| ~createDialogOpen~ | bool | Create file/folder dialog visible |

** Selection State
:PROPERTIES:
:FILE: internal/ui/renderer.go
:LINES: 487-503
:END:

| Field | Type | Purpose |
|-------+------+---------|
| ~SelectedIndex~ | int | Primary selection (-1 if none) |
| ~SelectedIndices~ | map[int]bool | Multi-select items |

* Special Click Behaviors

** Inline Rename
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1107-1131
:END:

Triggers:
- Right-click menu item
- Keyboard shortcut

Behavior:
- Shows text editor in place of filename
- Enter submits, Escape cancels
- For files: Pre-selects name without extension

** Resize Handle
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 275-373
:END:

Preview pane left edge is draggable:
- Tracks ~pointer.Press~, ~pointer.Drag~, ~pointer.Release~
- Updates ~r.previewWidth~ while dragging
- Respects min/max constraints

** Tab Close Button
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINE: 1624
:END:

- Small X button on each tab
- Click triggers ~ActionCloseTab~
- Does NOT close last tab

** Favorite Right-Click
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1127-1147
:END:

Favorites in sidebar have separate right-click handling:
- Shows same context menu as file list items
- Positioned relative to mouse (~r.menuPos = r.mousePos~)

** Drive List Click
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1167-1177
:END:

- Simple left-click navigation
- No multi-select
- No right-click menu

* Event Flow Diagram

#+BEGIN_SRC
Input Event (Mouse/Keyboard)
    |
    v
Gio Framework captures pointer.Event or key.Event
    |
    v
Layout() processes events:
  1. Global mouse position tracking (layout.go:37-58)
  2. Keyboard input (processGlobalInput)
  3. Specific element handlers (breadcrumb, search, buttons, etc.)
  4. File list click detection (renderRow, layout.go:1362-1404)
  5. Background click detection (layout.go:1279-1420)
  6. Context menu positioning (layout.go:1806-1901)
    |
    v
Returns UIEvent{Action, Path, NewIndex, Modifiers, ...}
    |
    v
orchestrator.handleUIEvent() processes action:
  - ActionSelect -> Updates selection, shows preview
  - ActionToggleSelect -> Manages multi-select map
  - ActionNavigate -> Navigates directory
  - ActionOpen -> Opens file
  - ActionCopy/Cut -> Sets clipboard
  - ActionDelete -> Shows confirmation
  - ActionRename -> Triggers rename UI
  - ... 30+ other actions
    |
    v
Updates o.state, refreshes UI
    |
    v
Next frame renders with updated state
#+END_SRC

* Double-Click Detection

** Implementation
:PROPERTIES:
:FILE: internal/ui/layout.go
:LINES: 1368-1403
:END:

#+BEGIN_SRC go
now := time.Now()
isDoubleClick := r.lastClickIndex == i &&
    !r.lastClickTime.IsZero() &&
    now.Sub(r.lastClickTime) < doubleClickInterval
#+END_SRC

** Constants
:PROPERTIES:
:LINE: 30
:END:

#+BEGIN_SRC go
doubleClickInterval = 200 * time.Millisecond
#+END_SRC

** Behavior

- Same item, two clicks within 200ms = double-click
- Different item = single click (updates tracking)
- No inherent delay - selection happens on first click, action on second

* Key Code Locations Reference

| Feature | File | Lines |
|---------+------+-------|
| Global click loop | orchestrator.go | 238-256 |
| UI event return | layout.go | 34, 222 |
| Global mouse tracking | layout.go | 37-58 |
| File list clicks | layout.go | 1253-1426 |
| Row rendering | renderer.go | 1431-1537 |
| Background right-click | layout.go | 1279-1420 |
| Context menu layout | layout.go | 1806-2013 |
| Click event handling | orchestrator.go | 289-528 |
| Selection state | orchestrator.go | 316-398 |
| Multi-select logic | orchestrator.go | 330-378 |
| Keyboard shortcuts | renderer.go | 1285-1375 |
| Breadcrumb clicks | layout.go | 276-305 |
| Tab clicks | layout.go | 1618-1627 |
| Button styles | renderer.go | 1193-1223 |
| Pointer events | renderer.go | 275-373, 1448-1456, 1642-1650 |
| Modifier detection | layout.go:1436, renderer.go | 1341-1356 |

* Critical Implementation Notes

1. *PassOp Pattern*: The right-click on empty space uses ~pointer.PassOp{}~ to allow events to pass through layers (important for multi-layer event handling).

2. *Event Consumption*: Gio's ~Clickable~ widget consumes click events in its handler. Events must be checked BEFORE calling the widget's Layout function.

3. *Modifier Capture*: Modifiers are captured from global pointer Press event (line 55), then used in file list click handler (line 1436).

4. *No Selection Change on Right-Click*: Right-clicking doesn't change selection - it uses ~collectSelectedPaths()~ to get all selected items for context menu operations.

5. *Double-Click Priority*: Double-click detection uses exact same index comparison, so items must track ~lastClickIndex~ correctly.

6. *Context Menu Positioning*: Uses global ~r.mousePos~ from global tracker, not event-local coordinates, for reliable positioning.

* Actions Reference

Complete list of click-triggered actions handled in ~orchestrator.go~:

| Action | Description |
|--------+-------------|
| ActionSelect | Single item selection |
| ActionToggleSelect | Toggle item in multi-select |
| ActionRangeSelect | Select range of items |
| ActionClearSelection | Clear all selection |
| ActionNavigate | Navigate to directory |
| ActionOpen | Open file with default app |
| ActionOpenWith | Open file chooser dialog |
| ActionBack | Navigate back in history |
| ActionForward | Navigate forward in history |
| ActionHome | Navigate to home directory |
| ActionCopy | Copy selected items to clipboard |
| ActionCut | Cut selected items to clipboard |
| ActionPaste | Paste from clipboard |
| ActionDelete | Delete selected items |
| ActionConfirmDelete | Show delete confirmation |
| ActionRename | Start inline rename |
| ActionAddFavorite | Add path to favorites |
| ActionRemoveFavorite | Remove path from favorites |
| ActionOpenInNewTab | Open directory in new tab |
| ActionNewTab | Create new tab |
| ActionCloseTab | Close current tab |
| ActionSwitchTab | Switch to different tab |
| ActionSort | Change sort column/direction |
| ActionSearch | Execute search |
| ActionClearSearch | Clear search query |
| ActionNewWindow | Open new window |
| ActionSettings | Open settings dialog |
