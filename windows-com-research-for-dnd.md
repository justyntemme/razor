# Windows COM Research for Drag-and-Drop in Go

This document contains comprehensive research on implementing Windows OLE/COM drag-and-drop in Go, specifically for the IDropTarget interface. This research was conducted to understand why previous attempts failed and what approaches might succeed.

---

## Quick Reference

### The Root Cause (FIXED in Go 1.11)
**Go Issue #20823**: `syscall.NewCallback` fails when called from external threads without CGO. OLE drag-drop callbacks come from Windows Explorer's thread.

**FIXED**: [CL 114802](https://go-review.googlesource.com/c/go/+/114802) merged June 2018 (Go 1.11+). The runtime now pre-allocates an extra M for external thread callbacks. **CGO should no longer be required on Go 1.11+.**

### Legacy Workaround (Go < 1.11)
```go
import "C"  // Just this line enables external thread callbacks
```
Requires MinGW (C compiler).

### Best Library Options
1. **windigo** - Pure Go IDropTarget via `ole.NewIDropTargetImpl()` (untested with Gio)
2. **go-ole** - Good for calling COM, not implementing callbacks
3. **Wails combridge** - Production-proven pattern for COM callbacks

### Key Rules
- Use `OleInitialize()`, NOT `CoInitialize()`
- Call `runtime.LockOSThread()` before OLE operations
- Use `ReleaseStgMedium()` for IDropTarget, `DragFinish()` for WM_DROPFILES (never both!)
- Call `RevokeDragDrop()` BEFORE destroying window

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [The Core Problem: Go Issue #20823](#the-core-problem-go-issue-20823)
3. [Detailed Windows API Patterns for Go](#detailed-windows-api-patterns-for-go)
4. [COM Fundamentals](#com-fundamentals)
5. [IDropTarget Interface](#idroptarget-interface)
6. [Complete IDropTarget Implementation Guide](#complete-idroptarget-implementation-guide)
7. [Handler Signature Differences](#handler-signature-differences-wm_dropfiles-vs-idroptarget)
8. [Required Windows APIs](#required-windows-apis)
9. [Data Structures](#data-structures)
10. [Memory Management](#memory-management)
11. [Threading Requirements](#threading-requirements)
12. [Go-Specific Patterns](#go-specific-patterns)
13. [Existing Go Libraries](#existing-go-libraries)
14. [Implementation Approaches](#implementation-approaches)
15. [Pitfalls and Gotchas](#pitfalls-and-gotchas)
16. [Sources](#sources)
17. [Gio UI Considerations](#gio-ui-considerations)
18. [Recommended Next Steps](#recommended-next-steps)
19. [Open Questions (With Answers)](#open-questions-with-answers)
20. [Test Plan for windigo IDropTarget](#test-plan-for-windigo-idroptarget)
21. [Alternative Approaches to Windows API Calls in Go](#alternative-approaches-to-windows-api-calls-in-go)
22. [COM Object Memory Layout In Depth](#com-object-memory-layout-in-depth)
23. [C++ IDropTarget Reference Implementation](#c-idroptarget-reference-implementation)
24. [FORMATETC and STGMEDIUM Memory Structures](#formatetc-and-stgmedium-memory-structures)

---

## Executive Summary

### Why Our Previous Attempts Failed

All our attempts to implement Windows drag-and-drop using IDropTarget failed because of **Go Issue #20823**: `syscall.NewCallback` does not work properly when callbacks are invoked from external threads (threads not created by the Go runtime).

When Windows Explorer drags files over our window, it calls IDropTarget methods from its own OLE thread. Without CGO enabled, the Go runtime isn't initialized on that thread, so callbacks silently fail or cause the application to hang.

### The Workaround

The counterintuitive solution is to import the C package (even without using it):

```go
import "C"  // Adding this import alone enables external thread callbacks
```

However, this requires a C compiler (MinGW on Windows), which introduced additional complications in our build process.

### Alternative Approaches

1. **WM_DROPFILES** - Simpler but limited (no hover highlighting)
2. **CGO with proper MinGW setup** - Full functionality but build complexity
3. **Wails combridge pattern** - Pure Go but complex implementation

---

## The Core Problem: Go Issue #20823

### Description

The callback wrapper generated by `syscall.NewCallback` does not perform the needed steps to set up the call stack as needed by the Go runtime for a new thread unless "C" is imported.

**Source**: [golang/go#20823](https://github.com/golang/go/issues/20823)

### Technical Explanation

Before the CGO import, the code hangs at `lockextra()` waiting for an extra "m" (machine/OS thread abstraction in Go). The assumption that there is an extra "m" created doesn't hold true without CGO. The `needm` function requires that if CGO is in use, the list is seeded with a single "m".

Since `syscall.NewCallback` uses the common `runtime.cgocallback_gofunc` procedure, it will create a new "m" for your callback if started on a new threadâ€”but only if CGO is enabled.

### The Official Fix: CL 114802 (Go 1.11+)

**IMPORTANT**: This issue was officially fixed in **Go 1.11** via [CL 114802](https://go-review.googlesource.com/c/go/+/114802).

**Commit Details**:
- **Title**: `runtime: handle windows callback on non-go thread`
- **Author**: Bill Zissimopoulos
- **Merged**: June 5, 2018
- **Fixes**: [golang/go#6751](https://github.com/golang/go/issues/6751)
- **PR**: [golang/go#25575](https://github.com/golang/go/pull/25575)

**The Solution**:
> "Adds an extra M in mstartm0 and accounts for it in checkdead. This allows Windows callbacks created with syscall.NewCallback and syscall.NewCallbackCDecl to be called on a non-Go thread."

**What This Means for Razor**:
- If using **Go 1.11 or later**, `syscall.NewCallback` should work on external threads **without requiring `import "C"`**
- The runtime now pre-allocates an extra M (machine/OS thread abstraction) during startup
- The `checkdead` function was updated to account for this extra M, preventing false deadlock detection

**Files Changed**: `src/runtime/proc.go` (+18 lines, -5 lines)

**Implications for windigo Testing**:
- windigo's IDropTarget implementation should work without CGO on Go 1.11+
- Our previous failures may have been due to other issues (vtable layout, COM initialization, etc.)
- Worth re-testing with explicit Go version verification

### Reproducible Test Case

```go
package main

import "C"  // Uncomment this and it works

import (
    "fmt"
    "syscall"
    "time"
)

func ThreadProc() uintptr {
    fmt.Println("Thread running!")
    return 0
}

func main() {
    modkernel32 := syscall.MustLoadDLL("kernel32.dll")
    procCreateThread := modkernel32.MustFindProc("CreateThread")

    r1, _, _ := procCreateThread.Call(
        0, 0,
        syscall.NewCallback(ThreadProc),
        0, 0, 0,
    )
    fmt.Printf("Thread handle: %v\n", r1)
    time.Sleep(time.Second)
}
```

Without the `import "C"` line, the spawned thread hangs forever.

### Related Issues

- [golang/go#9240](https://github.com/golang/go/issues/9240) - syscall: cannot call Win32 API functions that spawn new threads
- [golang/go#21831](https://github.com/golang/go/issues/21831) - x/sys/windows: NewCallback function does not work
- [golang/go#6751](https://github.com/golang/go/issues/6751) - runtime: windows callback on non-Go thread fails

---

## Detailed Windows API Patterns for Go

This section is based on Justen Walker's article "Breaking all the rules: Using Go to call Windows API" and provides essential patterns for working with Windows APIs from Go.

### The syscall Package

The Go `syscall` library is platform-specific. You MUST use conditional compilation:

**File naming convention**:
- `name_windows.go` - compiled only for Windows
- `name_windows_amd64.go` - compiled only for Windows on AMD64

**Build tags**:
```go
//go:build windows
```

### Loading DLLs

```go
// Lazy loading (loads on first use)
kernel32DLL := syscall.NewLazyDLL("kernel32.dll")

// Immediate loading
dll, err := syscall.LoadLibrary("kernel32.dll")

// SECURE loading (recommended) - constrains search to System directory
kernel32DLL := windows.NewLazySystemDLL("kernel32.dll")
```

### Calling Procedures

```go
var (
    kernel32DLL     = syscall.NewLazyDLL("kernel32.dll")
    procOpenProcess = kernel32DLL.NewProc("OpenProcess")
)

// Using Call method
r1, r2, err := procOpenProcess.Call(arg1, arg2, arg3)

// Using Syscall directly (slightly faster)
r1, r2, err := syscall.Syscall(procOpenProcess.Addr(), 3, arg1, arg2, arg3)
```

**Syscall variants by argument count**:
- `syscall.Syscall` - up to 3 arguments
- `syscall.Syscall6` - 4 to 6 arguments
- `syscall.Syscall9` - 7 to 9 arguments
- `syscall.Syscall12` - 10 to 12 arguments
- `syscall.Syscall15` - 13 to 15 arguments (max)

### Windows C Types to Go Types

```go
type (
    BOOL          uint32
    BOOLEAN       byte
    BYTE          byte
    DWORD         uint32
    DWORD64       uint64
    HANDLE        uintptr
    HLOCAL        uintptr
    LARGE_INTEGER int64
    LONG          int32
    LPVOID        uintptr
    SIZE_T        uintptr
    UINT          uint32
    ULONG_PTR     uintptr
    ULONGLONG     uint64
    WORD          uint16
)
```

### C Structs to Go Structs

Windows C struct:
```c
typedef struct _SECURITY_ATTRIBUTES {
    DWORD  nLength;
    LPVOID lpSecurityDescriptor;
    BOOL   bInheritHandle;
} SECURITY_ATTRIBUTES;
```

Go equivalent:
```go
type SecurityAttributes struct {
    Length             uint32
    SecurityDescriptor uintptr
    InheritHandle      uint32
}
```

### Working with Strings

**ANSI strings** (for `ProcNameA` functions):
```go
func StringToCharPtr(str string) *byte {
    chars := append([]byte(str), 0) // null-terminated
    return &chars[0]
}
```

**UTF-16 strings** (for `ProcNameW` functions):
```go
func StringToUTF16Ptr(str string) *uint16 {
    ptr, _ := syscall.UTF16PtrFromString(str)
    return ptr
}
```

### Pointer Passing Rules

**CRITICAL**: Pointers must be converted in the call expression itself:

```go
// CORRECT - conversion happens in the call
syscall.Syscall(
    proc.Addr(), 3,
    uintptr(unsafe.Pointer(&myStruct)),  // Converted here
    uintptr(unsafe.Pointer(&buffer[0])),
    uintptr(bufLen),
)

// WRONG - pointer may become invalid before syscall
ptr := uintptr(unsafe.Pointer(&myStruct))  // GC can move myStruct after this!
syscall.Syscall(proc.Addr(), 1, ptr, 0, 0)
```

### Working with ANY_SIZE Arrays

Windows APIs often return variable-size arrays. Pattern:

```go
// Windows structure with variable array
type MIB_TCPTABLE struct {
    dwNumEntries uint32
    table        [1]MIB_TCPROW  // Actually variable size
}

// To work with it:
pTable := (*MIB_TCPTABLE)(unsafe.Pointer(&buf[0]))

// Get actual array (using the 1<<30 trick)
rows := (*[1 << 30]MIB_TCPROW)(
    unsafe.Pointer(&pTable.table[0]),
)[:pTable.dwNumEntries:pTable.dwNumEntries]
```

### Syscall Return Values

`syscall.Syscall` returns `(r1, r2, err uintptr)`:
- **r1**: Return value of the function
- **r2**: Unused on Windows AMD64
- **err**: Windows error code from `GetLastError` (automatically called)

---

## COM Fundamentals

### What is COM?

Component Object Model (COM) is Microsoft's binary interface standard for software components. It enables inter-process communication and dynamic object creation.

### IUnknown Interface

All COM objects must implement IUnknown, which provides:

1. **QueryInterface** - Retrieves pointers to other interfaces the object supports
2. **AddRef** - Increments the reference count
3. **Release** - Decrements the reference count

### VTable (Virtual Table) Structure

COM uses virtual function tables (vtables) to provide polymorphism. The vtable is a table of function pointers, and the COM object contains a pointer to its vtable.

```go
// Go representation of IUnknown vtable
type IUnknownVtbl struct {
    QueryInterface uintptr  // func(this, riid, ppvObject) HRESULT
    AddRef         uintptr  // func(this) ULONG
    Release        uintptr  // func(this) ULONG
}

// COM object structure
type IUnknown struct {
    lpVtbl *IUnknownVtbl  // Pointer to vtable (must be first field)
}
```

### Calling Convention

COM methods use the `__stdcall` calling convention on Windows. The first parameter is always `this` (pointer to the object itself).

**Source**: [Stack Overflow - Call COM object method from Go without CGo](https://stackoverflow.com/questions/39162054/call-com-object-method-from-go-without-cgo)

---

## IDropTarget Interface

### Overview

IDropTarget is the COM interface that a window must implement to receive drag-and-drop operations. It inherits from IUnknown and adds four methods.

**Source**: [Microsoft Learn - IDropTarget](https://learn.microsoft.com/en-us/windows/win32/api/oleidl/nn-oleidl-idroptarget)

### Method Signatures

```c
// C/C++ declarations
interface IDropTarget : IUnknown {
    HRESULT DragEnter(IDataObject *pDataObj, DWORD grfKeyState,
                      POINTL pt, DWORD *pdwEffect);
    HRESULT DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT DragLeave(void);
    HRESULT Drop(IDataObject *pDataObj, DWORD grfKeyState,
                 POINTL pt, DWORD *pdwEffect);
};
```

### VTable Layout

```go
type IDropTargetVtbl struct {
    // IUnknown methods (must come first)
    QueryInterface uintptr  // Index 0
    AddRef         uintptr  // Index 1
    Release        uintptr  // Index 2

    // IDropTarget methods
    DragEnter      uintptr  // Index 3
    DragOver       uintptr  // Index 4
    DragLeave      uintptr  // Index 5
    Drop           uintptr  // Index 6
}
```

### Method Details

#### DragEnter

Called when the cursor first enters the window during a drag operation.

**Parameters**:
- `pDataObj` - IDataObject containing the dragged data
- `grfKeyState` - Keyboard modifier state (MK_CONTROL, MK_SHIFT, MK_ALT, etc.)
- `pt` - POINTL with cursor position in screen coordinates
- `pdwEffect` - In/Out: acceptable effects on input, chosen effect on output

**Implementation Requirements**:
1. Examine the data format via `IDataObject::QueryGetData`
2. Check the input `pdwEffect` value
3. Consider keyboard modifier state
4. Return appropriate DROPEFFECT based on key combinations:
   - CTRL + SHIFT = DROPEFFECT_LINK
   - CTRL only = DROPEFFECT_COPY
   - No keys or SHIFT = DROPEFFECT_MOVE

**Source**: [Microsoft Learn - DragEnter](https://learn.microsoft.com/en-us/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter)

#### DragOver

Called continuously as the cursor moves within the window.

**Parameters**: Same as DragEnter except no `pDataObj` (use the one from DragEnter).

**Note**: For efficiency, `pDataObj` is not passed to DragOver. Use the data object from the most recent DragEnter call.

**Source**: [Microsoft Learn - DragOver](https://learn.microsoft.com/en-us/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover)

#### DragLeave

Called when the cursor leaves the window or the operation is cancelled.

**Parameters**: None

**Implementation**: Clean up any visual feedback, reset cached state.

#### Drop

Called when the user releases the mouse button over the window.

**Parameters**: Same as DragEnter.

**Implementation**:
1. Extract data from `pDataObj`
2. Perform the actual drop operation
3. Set `pdwEffect` to indicate what happened

---

## Complete IDropTarget Implementation Guide

Based on the Catch22.net tutorial, here's a complete guide to implementing IDropTarget.

### Class Structure (C++ Reference)

```cpp
class CDropTarget : public IDropTarget {
public:
    // IUnknown methods
    HRESULT __stdcall QueryInterface(REFIID iid, void **ppvObject);
    ULONG   __stdcall AddRef(void);
    ULONG   __stdcall Release(void);

    // IDropTarget methods
    HRESULT __stdcall DragEnter(IDataObject *pDataObject, DWORD grfKeyState,
                                 POINTL pt, DWORD *pdwEffect);
    HRESULT __stdcall DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT __stdcall DragLeave(void);
    HRESULT __stdcall Drop(IDataObject *pDataObject, DWORD grfKeyState,
                           POINTL pt, DWORD *pdwEffect);

    // Constructor
    CDropTarget(HWND hwnd);

private:
    LONG  m_lRefCount;      // Reference count
    HWND  m_hWnd;           // Window handle for visual feedback
    bool  m_fAllowDrop;     // Cached: can we accept this data?

    // Helper methods
    bool  QueryDataObject(IDataObject *pDataObject);
    DWORD DropEffect(DWORD grfKeyState, POINTL pt, DWORD dwAllowed);
    void  DropData(HWND hwnd, IDataObject *pDataObject);
};
```

### Go Equivalent Structure

```go
type DropTarget struct {
    vtbl       *IDropTargetVtbl  // Must be first field!
    refCount   int32
    hwnd       uintptr
    allowDrop  bool
    dataObject uintptr  // Cached IDataObject from DragEnter
}

type IDropTargetVtbl struct {
    QueryInterface uintptr  // Index 0
    AddRef         uintptr  // Index 1
    Release        uintptr  // Index 2
    DragEnter      uintptr  // Index 3
    DragOver       uintptr  // Index 4
    DragLeave      uintptr  // Index 5
    Drop           uintptr  // Index 6
}
```

### QueryInterface Implementation

```go
func queryInterfaceCallback(this uintptr, riid uintptr, ppvObject uintptr) uintptr {
    // Compare GUID to IID_IUnknown and IID_IDropTarget
    guid := (*GUID)(unsafe.Pointer(riid))

    if *guid == IID_IUnknown || *guid == IID_IDropTarget {
        // Return pointer to this object
        *(*uintptr)(unsafe.Pointer(ppvObject)) = this
        // AddRef before returning
        addRefCallback(this)
        return S_OK
    }

    *(*uintptr)(unsafe.Pointer(ppvObject)) = 0
    return E_NOINTERFACE
}

var (
    IID_IUnknown = GUID{
        Data1: 0x00000000,
        Data2: 0x0000,
        Data3: 0x0000,
        Data4: [8]byte{0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46},
    }
    IID_IDropTarget = GUID{
        Data1: 0x00000122,
        Data2: 0x0000,
        Data3: 0x0000,
        Data4: [8]byte{0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46},
    }
)
```

### AddRef/Release Implementation

```go
func addRefCallback(this uintptr) uintptr {
    dt := (*DropTarget)(unsafe.Pointer(this))
    return uintptr(atomic.AddInt32(&dt.refCount, 1))
}

func releaseCallback(this uintptr) uintptr {
    dt := (*DropTarget)(unsafe.Pointer(this))
    newCount := atomic.AddInt32(&dt.refCount, -1)
    if newCount == 0 {
        // Object should be destroyed
        // In Go, we might remove from a pointer cache
    }
    return uintptr(newCount)
}
```

### DragEnter Implementation

```go
func dragEnterCallback(this uintptr, pDataObj uintptr, grfKeyState uint32,
    pt uintptr, pdwEffect uintptr) uintptr {

    dt := (*DropTarget)(unsafe.Pointer(this))

    // Cache the data object for use in DragOver
    dt.dataObject = pDataObj

    // Check if we can accept this data
    dt.allowDrop = queryDataObject(pDataObj)

    if dt.allowDrop {
        // Calculate appropriate effect
        effect := dropEffect(grfKeyState, pt, *(*uint32)(unsafe.Pointer(pdwEffect)))
        *(*uint32)(unsafe.Pointer(pdwEffect)) = effect
    } else {
        *(*uint32)(unsafe.Pointer(pdwEffect)) = DROPEFFECT_NONE
    }

    return S_OK
}
```

### Helper: QueryDataObject

```go
func queryDataObject(pDataObj uintptr) bool {
    // Create FORMATETC for CF_HDROP
    formatetc := FORMATETC{
        CfFormat: CF_HDROP,
        Ptd:      0,
        DwAspect: DVASPECT_CONTENT,
        Lindex:   -1,
        Tymed:    TYMED_HGLOBAL,
    }

    // Call IDataObject::QueryGetData
    dataObj := (*IDataObject)(unsafe.Pointer(pDataObj))
    vtbl := (*IDataObjectVtbl)(unsafe.Pointer(dataObj.lpVtbl))

    hr, _, _ := syscall.Syscall(
        vtbl.QueryGetData,
        2,
        pDataObj,
        uintptr(unsafe.Pointer(&formatetc)),
        0,
    )

    return hr == S_OK
}
```

### Helper: DropEffect

```go
func dropEffect(grfKeyState uint32, pt uintptr, dwAllowed uint32) uint32 {
    var effect uint32 = DROPEFFECT_NONE

    // Determine effect based on keyboard state
    if (grfKeyState & (MK_CONTROL | MK_SHIFT)) == (MK_CONTROL | MK_SHIFT) {
        effect = DROPEFFECT_LINK
    } else if (grfKeyState & MK_CONTROL) != 0 {
        effect = DROPEFFECT_COPY
    } else if (grfKeyState & MK_SHIFT) != 0 {
        effect = DROPEFFECT_MOVE
    } else {
        // Default: prefer MOVE, then COPY, then LINK
        if (dwAllowed & DROPEFFECT_MOVE) != 0 {
            effect = DROPEFFECT_MOVE
        } else if (dwAllowed & DROPEFFECT_COPY) != 0 {
            effect = DROPEFFECT_COPY
        } else if (dwAllowed & DROPEFFECT_LINK) != 0 {
            effect = DROPEFFECT_LINK
        }
    }

    // Only return effects that are allowed
    return effect & dwAllowed
}
```

### Keyboard Modifier Constants

```go
const (
    MK_LBUTTON  = 0x0001
    MK_RBUTTON  = 0x0002
    MK_SHIFT    = 0x0004
    MK_CONTROL  = 0x0008
    MK_MBUTTON  = 0x0010
    MK_ALT      = 0x0020
)
```

### DragOver Implementation

```go
func dragOverCallback(this uintptr, grfKeyState uint32, pt uintptr,
    pdwEffect uintptr) uintptr {

    dt := (*DropTarget)(unsafe.Pointer(this))

    if dt.allowDrop {
        effect := dropEffect(grfKeyState, pt, *(*uint32)(unsafe.Pointer(pdwEffect)))
        *(*uint32)(unsafe.Pointer(pdwEffect)) = effect
    } else {
        *(*uint32)(unsafe.Pointer(pdwEffect)) = DROPEFFECT_NONE
    }

    return S_OK
}
```

### DragLeave Implementation

```go
func dragLeaveCallback(this uintptr) uintptr {
    dt := (*DropTarget)(unsafe.Pointer(this))

    // Clear cached data
    dt.allowDrop = false
    dt.dataObject = 0

    return S_OK
}
```

### Drop Implementation

```go
func dropCallback(this uintptr, pDataObj uintptr, grfKeyState uint32,
    pt uintptr, pdwEffect uintptr) uintptr {

    dt := (*DropTarget)(unsafe.Pointer(this))

    if dt.allowDrop {
        // Extract file paths
        paths := extractDroppedFiles(pDataObj)

        // Notify application
        if dropHandler != nil {
            dropHandler(paths, getCurrentDropTarget())
        }

        // Set effect that was performed
        *(*uint32)(unsafe.Pointer(pdwEffect)) = DROPEFFECT_COPY
    } else {
        *(*uint32)(unsafe.Pointer(pdwEffect)) = DROPEFFECT_NONE
    }

    return S_OK
}

func extractDroppedFiles(pDataObj uintptr) []string {
    formatetc := FORMATETC{
        CfFormat: CF_HDROP,
        Ptd:      0,
        DwAspect: DVASPECT_CONTENT,
        Lindex:   -1,
        Tymed:    TYMED_HGLOBAL,
    }

    var stgmedium STGMEDIUM

    // Get the data
    dataObj := (*IDataObject)(unsafe.Pointer(pDataObj))
    vtbl := (*IDataObjectVtbl)(unsafe.Pointer(dataObj.lpVtbl))

    hr, _, _ := syscall.Syscall(
        vtbl.GetData,
        3,
        pDataObj,
        uintptr(unsafe.Pointer(&formatetc)),
        uintptr(unsafe.Pointer(&stgmedium)),
    )

    if hr != S_OK {
        return nil
    }

    // stgmedium.Data is now an HDROP
    hdrop := stgmedium.Data

    // Get file count
    count := DragQueryFileCount(hdrop)

    paths := make([]string, count)
    for i := uint32(0); i < count; i++ {
        paths[i] = DragQueryFile(hdrop, i)
    }

    // Release the storage medium (NOT DragFinish!)
    ReleaseStgMedium(&stgmedium)

    return paths
}
```

### Registration and Cleanup

```go
func RegisterDropTarget(hwnd uintptr) error {
    // Create drop target
    dt := createDropTarget(hwnd)

    // Register with Windows
    hr, _, _ := procRegisterDragDrop.Call(hwnd, uintptr(unsafe.Pointer(dt)))
    if hr != S_OK {
        return fmt.Errorf("RegisterDragDrop failed: 0x%x", hr)
    }

    return nil
}

func UnregisterDropTarget(hwnd uintptr) {
    procRevokeDragDrop.Call(hwnd)
}
```

**Source**: [Catch22.net - Drop Target Tutorial](https://www.catch22.net/tuts/ole/drop-target/)

---

## Handler Signature Differences: WM_DROPFILES vs IDropTarget

**IMPORTANT**: Our existing Razor handler signatures differ significantly from IDropTarget COM callback signatures. This section documents these differences to help with integration.

### Current Razor Handlers (drop_windows.go)

```go
// Current application-level handlers
type DropHandler func(paths []string, targetDir string)
type DragUpdateHandler func(x, y int)
type DragEndHandler func()
```

These handlers are designed for high-level application use, receiving:
- Pre-processed file paths as Go strings
- Screen coordinates as Go ints
- No complex Windows structures

### IDropTarget COM Callback Signatures

```go
// COM callback signatures (low-level, Windows ABI)
type DragEnterCallback func(this uintptr, pDataObj uintptr, grfKeyState uint32,
                            pt uintptr, pdwEffect uintptr) uintptr

type DragOverCallback func(this uintptr, grfKeyState uint32,
                           pt uintptr, pdwEffect uintptr) uintptr

type DragLeaveCallback func(this uintptr) uintptr

type DropCallback func(this uintptr, pDataObj uintptr, grfKeyState uint32,
                       pt uintptr, pdwEffect uintptr) uintptr
```

COM callbacks receive:
- Raw `uintptr` pointers to COM objects
- POINTL packed as a single uintptr (on x64)
- Pointers to output parameters (pdwEffect)
- Must return HRESULT as uintptr

### Integration Strategy

The IDropTarget COM callbacks must be **adapters** that:
1. Convert COM parameters to Go types
2. Call the existing high-level Razor handlers
3. Return appropriate HRESULT values

```go
// Adapter layer between COM callbacks and Razor handlers
func comDragEnterAdapter(this uintptr, pDataObj uintptr, grfKeyState uint32,
    pt uintptr, pdwEffect uintptr) uintptr {

    // Extract coordinates from POINTL
    x, y := unpackPOINTL(pt)

    // Check if we can accept this data
    canAccept := queryDataObject(pDataObj)

    // Call our high-level handler
    if dragUpdateHandler != nil {
        dragUpdateHandler(int(x), int(y))
    }

    // Set effect based on acceptance
    if canAccept {
        *(*uint32)(unsafe.Pointer(pdwEffect)) = DROPEFFECT_COPY
    } else {
        *(*uint32)(unsafe.Pointer(pdwEffect)) = DROPEFFECT_NONE
    }

    return S_OK
}

func comDropAdapter(this uintptr, pDataObj uintptr, grfKeyState uint32,
    pt uintptr, pdwEffect uintptr) uintptr {

    // Extract file paths from IDataObject
    paths := extractDroppedFiles(pDataObj)

    // Call our high-level handler with processed data
    if dropHandler != nil {
        targetDir := GetCurrentDropTarget()
        dropHandler(paths, targetDir)
    }

    *(*uint32)(unsafe.Pointer(pdwEffect)) = DROPEFFECT_COPY
    return S_OK
}

func comDragLeaveAdapter(this uintptr) uintptr {
    // Call our high-level handler
    if dragEndHandler != nil {
        dragEndHandler()
    }
    return S_OK
}
```

### Key Differences Table

| Aspect | Razor Handlers | COM Callbacks |
|--------|----------------|---------------|
| **Calling convention** | Go standard | Windows stdcall |
| **First parameter** | None | `this` pointer |
| **Data format** | Processed strings | Raw COM pointers |
| **Coordinates** | `int` parameters | POINTL struct (packed) |
| **Return value** | None | HRESULT (uintptr) |
| **Error handling** | Go error/panic | Return error HRESULT |
| **Thread context** | Go goroutine | External Windows thread |

### Recommendations

1. **Keep existing handlers**: Don't change the high-level `DropHandler`, `DragUpdateHandler`, `DragEndHandler` signatures
2. **Add adapter layer**: Create COM-to-Go adapter functions
3. **Thread safety**: COM callbacks may come from external threads - use mutex protection
4. **Caching**: Store IDataObject reference from DragEnter for use in DragOver

---

## Required Windows APIs

### OLE Initialization

```go
// MUST use OleInitialize, NOT CoInitialize or CoInitializeEx
// Using CoInitialize causes RegisterDragDrop to return E_OUTOFMEMORY

var (
    ole32              = windows.NewLazySystemDLL("ole32.dll")
    procOleInitialize  = ole32.NewProc("OleInitialize")
    procOleUninitialize = ole32.NewProc("OleUninitialize")
)

func OleInitialize() error {
    hr, _, _ := procOleInitialize.Call(0)
    if hr != 0 {
        return fmt.Errorf("OleInitialize failed: 0x%x", hr)
    }
    return nil
}
```

**Critical**: `OleInitialize` initializes COM in STA (Single-Threaded Apartment) mode, which is required for OLE drag-and-drop. `CoInitialize` or `CoInitializeEx` will cause `RegisterDragDrop` to fail with `E_OUTOFMEMORY`.

**Source**: [Microsoft Learn - RegisterDragDrop](https://learn.microsoft.com/en-us/windows/win32/api/ole2/nf-ole2-registerdragdrop)

### RegisterDragDrop / RevokeDragDrop

```go
var (
    procRegisterDragDrop = ole32.NewProc("RegisterDragDrop")
    procRevokeDragDrop   = ole32.NewProc("RevokeDragDrop")
)

func RegisterDragDrop(hwnd uintptr, dropTarget *IDropTarget) error {
    hr, _, _ := procRegisterDragDrop.Call(
        hwnd,
        uintptr(unsafe.Pointer(dropTarget)),
    )
    if hr != 0 {
        return fmt.Errorf("RegisterDragDrop failed: 0x%x", hr)
    }
    return nil
}
```

**Return Values**:
| Code | Value | Meaning |
|------|-------|---------|
| S_OK | 0 | Success |
| DRAGDROP_E_INVALIDHWND | 0x80040100 | Invalid window handle |
| DRAGDROP_E_ALREADYREGISTERED | 0x80040101 | Window already registered |
| E_OUTOFMEMORY | 0x8007000E | COM not initialized with OleInitialize |

**Threading Requirement**: The calling thread MUST pump messages via `GetMessage` with a NULL hWnd parameter. If this requirement isn't met, any application that drags over the window will hang.

### DragQueryFile

For extracting file paths from CF_HDROP data:

```go
var (
    shell32           = windows.NewLazySystemDLL("shell32.dll")
    procDragQueryFileW = shell32.NewProc("DragQueryFileW")
    procDragFinish     = shell32.NewProc("DragFinish")
)

// Get count of files
func DragQueryFileCount(hDrop uintptr) uint32 {
    count, _, _ := procDragQueryFileW.Call(hDrop, 0xFFFFFFFF, 0, 0)
    return uint32(count)
}

// Get file path at index
func DragQueryFile(hDrop uintptr, index uint32) string {
    // First, get required buffer size
    size, _, _ := procDragQueryFileW.Call(hDrop, uintptr(index), 0, 0)
    if size == 0 {
        return ""
    }

    // Allocate buffer and get path
    buf := make([]uint16, size+1)
    procDragQueryFileW.Call(
        hDrop,
        uintptr(index),
        uintptr(unsafe.Pointer(&buf[0])),
        uintptr(len(buf)),
    )
    return windows.UTF16ToString(buf)
}
```

**Source**: [Microsoft Learn - DragQueryFileW](https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-dragqueryfilew)

---

## Data Structures

### POINTL

Used for cursor coordinates in drag-and-drop operations.

```go
type POINTL struct {
    X int32
    Y int32
}
```

**Important**: On Windows x64, POINTL may be passed as a single 64-bit value in some cases, not as two separate int32 parameters. This was one issue we encountered.

**Source**: [Microsoft Learn - POINTL](https://learn.microsoft.com/en-us/windows/win32/api/windef/ns-windef-pointl)

### FORMATETC

Describes the format of data in a transfer operation.

```go
type FORMATETC struct {
    CfFormat uint16        // Clipboard format (e.g., CF_HDROP)
    Ptd      uintptr       // Pointer to DVTARGETDEVICE (usually nil)
    DwAspect uint32        // DVASPECT value (usually DVASPECT_CONTENT = 1)
    Lindex   int32         // Index (-1 for all)
    Tymed    uint32        // Storage medium type (e.g., TYMED_HGLOBAL = 1)
}

// Common values
const (
    CF_HDROP         = 15
    DVASPECT_CONTENT = 1
    TYMED_HGLOBAL    = 1
)
```

**Source**: [pinvoke.net - FORMATETC](https://www.pinvoke.net/default.aspx/Structures/FORMATETC.html)

### STGMEDIUM

Describes the storage medium for transferred data.

```go
type STGMEDIUM struct {
    Tymed          uint32  // Type of storage medium
    Data           uintptr // Union: hGlobal, hBitmap, etc. based on tymed
    PUnkForRelease uintptr // IUnknown for releasing (can be nil)
}
```

When `Tymed` is `TYMED_HGLOBAL`, `Data` contains an HGLOBAL handle that can be locked with `GlobalLock` to access the actual data.

### DROPFILES

Structure at the beginning of CF_HDROP data.

```go
type DROPFILES struct {
    PFiles uint32  // Offset to file list
    Pt     POINT   // Drop point (in client coords if fNC is FALSE)
    FNC    int32   // TRUE if dropped on non-client area
    FWide  int32   // TRUE if file names are Unicode
}
```

The file paths follow immediately after this structure, as a double-null-terminated list of strings.

**Memory Layout Example** (for files `c:\temp1.txt` and `c:\temp2.txt`):
```
[DROPFILES header][c:\temp1.txt\0][c:\temp2.txt\0][\0]
```

**Source**: [Microsoft Learn - Shell Clipboard Formats](https://learn.microsoft.com/en-us/windows/win32/shell/clipboard)

### DROPEFFECT Constants

```go
const (
    DROPEFFECT_NONE   = 0          // Drop not allowed
    DROPEFFECT_COPY   = 1          // Copy the data
    DROPEFFECT_MOVE   = 2          // Move the data
    DROPEFFECT_LINK   = 4          // Create a link
    DROPEFFECT_SCROLL = 0x80000000 // Scrolling is occurring
)
```

### IDataObject VTable Structure

When calling methods on the IDataObject passed to DragEnter/Drop, you need to know the VTable layout:

```go
type IDataObjectVtbl struct {
    // IUnknown methods (indices 0-2)
    QueryInterface uintptr  // Index 0
    AddRef         uintptr  // Index 1
    Release        uintptr  // Index 2

    // IDataObject methods (indices 3-11)
    GetData              uintptr  // Index 3 - Get data in specified format
    GetDataHere          uintptr  // Index 4 - Get data into caller's medium
    QueryGetData         uintptr  // Index 5 - Check if format is available
    GetCanonicalFormatEtc uintptr // Index 6 - Get canonical format
    SetData              uintptr  // Index 7 - Set data
    EnumFormatEtc        uintptr  // Index 8 - Enumerate available formats
    DAdvise              uintptr  // Index 9 - Set up advisory connection
    DUnadvise            uintptr  // Index 10 - Delete advisory connection
    EnumDAdvise          uintptr  // Index 11 - Enumerate advisory connections
}

type IDataObject struct {
    lpVtbl uintptr  // Pointer to vtable
}
```

### Calling IDataObject Methods

```go
// Check if CF_HDROP format is available
func QueryGetData(dataObj uintptr, formatetc *FORMATETC) bool {
    obj := (*IDataObject)(unsafe.Pointer(dataObj))
    vtbl := (*IDataObjectVtbl)(unsafe.Pointer(obj.lpVtbl))

    hr, _, _ := syscall.Syscall(
        vtbl.QueryGetData,
        2,
        dataObj,
        uintptr(unsafe.Pointer(formatetc)),
        0,
    )

    return hr == S_OK  // S_OK = 0
}

// Get the actual data
func GetData(dataObj uintptr, formatetc *FORMATETC, stgmedium *STGMEDIUM) error {
    obj := (*IDataObject)(unsafe.Pointer(dataObj))
    vtbl := (*IDataObjectVtbl)(unsafe.Pointer(obj.lpVtbl))

    hr, _, _ := syscall.Syscall(
        vtbl.GetData,
        3,
        dataObj,
        uintptr(unsafe.Pointer(formatetc)),
        uintptr(unsafe.Pointer(stgmedium)),
    )

    if hr != S_OK {
        return fmt.Errorf("GetData failed: 0x%x", hr)
    }
    return nil
}
```

### ReleaseStgMedium Function

**CRITICAL**: After calling GetData, you MUST release the storage medium.

```go
var (
    ole32                = windows.NewLazySystemDLL("ole32.dll")
    procReleaseStgMedium = ole32.NewProc("ReleaseStgMedium")
)

func ReleaseStgMedium(pmedium *STGMEDIUM) {
    // Note: ReleaseStgMedium modifies the STGMEDIUM structure!
    // After calling, pmedium.Tymed will be set to TYMED_NULL
    procReleaseStgMedium.Call(uintptr(unsafe.Pointer(pmedium)))
}
```

**Important behavior**: ReleaseStgMedium clears the fields it releases:
- Sets `tymed` to `TYMED_NULL`
- Leaves the pointer as-is (doesn't set to nil)

**Source**: [Microsoft Learn - ReleaseStgMedium](https://learn.microsoft.com/en-us/windows/win32/api/ole2/nf-ole2-releasestgmedium), [pinvoke.net](http://www.pinvoke.net/default.aspx/ole32.releasestgmedium)

### Complete File Extraction Example

```go
func ExtractDroppedFiles(pDataObj uintptr) ([]string, error) {
    // Set up format request for CF_HDROP
    formatetc := FORMATETC{
        CfFormat: CF_HDROP,          // 15
        Ptd:      0,                 // No target device
        DwAspect: DVASPECT_CONTENT,  // 1
        Lindex:   -1,                // All items
        Tymed:    TYMED_HGLOBAL,     // 1
    }

    // Check if the format is available first
    if !QueryGetData(pDataObj, &formatetc) {
        return nil, fmt.Errorf("CF_HDROP format not available")
    }

    // Get the data
    var stgmedium STGMEDIUM
    if err := GetData(pDataObj, &formatetc, &stgmedium); err != nil {
        return nil, err
    }

    // MUST release when done - use defer
    defer ReleaseStgMedium(&stgmedium)

    // stgmedium.Data is an HDROP handle
    hdrop := stgmedium.Data

    // Get file count
    count := DragQueryFileCount(hdrop)
    if count == 0 {
        return nil, nil
    }

    // Extract each file path
    paths := make([]string, count)
    for i := uint32(0); i < count; i++ {
        paths[i] = DragQueryFile(hdrop, i)
    }

    return paths, nil
}
```

**Important**: Always use bitwise AND when checking effects:
```go
if (dwDropEffect & DROPEFFECT_COPY) == DROPEFFECT_COPY {
    // Copy is acceptable
}
```

**Source**: [Microsoft Learn - DROPEFFECT Constants](https://learn.microsoft.com/en-us/windows/win32/com/dropeffect-constants)

---

## Memory Management

### GlobalAlloc for COM Objects

COM objects and their vtables should be allocated using Windows `GlobalAlloc`, not Go's heap. This ensures the memory remains valid and isn't moved by Go's garbage collector.

```go
var (
    kernel32        = windows.NewLazySystemDLL("kernel32.dll")
    procGlobalAlloc = kernel32.NewProc("GlobalAlloc")
    procGlobalFree  = kernel32.NewProc("GlobalFree")
    procGlobalLock  = kernel32.NewProc("GlobalLock")
    procGlobalUnlock = kernel32.NewProc("GlobalUnlock")
)

const (
    GMEM_FIXED    = 0x0000
    GMEM_MOVEABLE = 0x0002
    GMEM_ZEROINIT = 0x0040
    GPTR          = GMEM_FIXED | GMEM_ZEROINIT
    GHND          = GMEM_MOVEABLE | GMEM_ZEROINIT
)

func GlobalAlloc(flags uint32, size uintptr) uintptr {
    ptr, _, _ := procGlobalAlloc.Call(uintptr(flags), size)
    return ptr
}

func GlobalFree(ptr uintptr) {
    procGlobalFree.Call(ptr)
}
```

**When to Use GlobalAlloc**:
- OLE data objects (clipboard, drag-and-drop)
- COM vtable memory (debated - some implementations use Go heap with pointer caching)
- Any memory that will be freed by external code

**Source**: [Microsoft Learn - GlobalAlloc](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalalloc)

### Preventing Go GC from Moving Memory

When creating COM objects on the Go heap, you must prevent the GC from collecting or moving them:

```go
var (
    // Global variables prevent GC collection
    dropTargetInstance *DropTarget
    vtableInstance     *IDropTargetVtbl
    pointerCache       = make(map[uintptr]interface{})
)
```

---

## Threading Requirements

### OLE Thread Model

OLE drag-and-drop requires the STA (Single-Threaded Apartment) model. Each thread that uses OLE must:

1. Call `OleInitialize()` (not `CoInitialize` or `CoInitializeEx`)
2. Process messages via `GetMessage`/`DispatchMessage`
3. Call `OleUninitialize()` before exiting

**Source**: [Stack Overflow - RegisterDragDrop Threading](https://stackoverflow.com/questions/41404779/how-to-combine-registerdragdrop-roinitialize-to-work-together-in-one-thread)

### Go's runtime.LockOSThread

Since Go uses M:N scheduling (goroutines mapped to OS threads dynamically), you must lock a goroutine to its OS thread when using COM:

```go
func initOLE() {
    runtime.LockOSThread()
    defer runtime.UnlockOSThread()

    if err := OleInitialize(); err != nil {
        panic(err)
    }

    // All OLE operations must happen on this thread
}
```

**Important**: `OleInitialize` must be called on the same thread that will process window messages and receive drag-drop events.

**Source**: [Go Wiki - LockOSThread](https://go.dev/wiki/LockOSThread)

### Message Pumping Requirement

RegisterDragDrop documentation states:
> "The calling thread must pump messages via GetMessage with a NULL hWnd parameter. If this requirement isn't met, then any application that drags an object over the window...will hang until the target application closes."

Gio's event loop should satisfy this requirement, but the thread calling `RegisterDragDrop` must be the same thread running the message loop.

---

## Go-Specific Patterns

### Creating COM Callbacks with syscall.NewCallback

```go
// Define callback functions matching COM method signatures
func queryInterfaceCallback(this uintptr, riid, ppvObject uintptr) uintptr {
    // Implementation
    return 0 // S_OK
}

func addRefCallback(this uintptr) uintptr {
    // Increment reference count
    return 1
}

func releaseCallback(this uintptr) uintptr {
    // Decrement reference count
    return 0
}

// Create vtable with callback pointers
vtable := &IDropTargetVtbl{
    QueryInterface: syscall.NewCallback(queryInterfaceCallback),
    AddRef:         syscall.NewCallback(addRefCallback),
    Release:        syscall.NewCallback(releaseCallback),
    DragEnter:      syscall.NewCallback(dragEnterCallback),
    DragOver:       syscall.NewCallback(dragOverCallback),
    DragLeave:      syscall.NewCallback(dragLeaveCallback),
    Drop:           syscall.NewCallback(dropCallback),
}
```

### Calling COM Methods via VTable

```go
func (obj *IDataObject) GetData(formatetc *FORMATETC, stgmedium *STGMEDIUM) error {
    vtbl := (*IDataObjectVtbl)(unsafe.Pointer(obj.lpVtbl))

    hr, _, _ := syscall.Syscall(
        vtbl.GetData,
        3, // Number of parameters including 'this'
        uintptr(unsafe.Pointer(obj)),
        uintptr(unsafe.Pointer(formatetc)),
        uintptr(unsafe.Pointer(stgmedium)),
    )

    if hr != 0 {
        return fmt.Errorf("GetData failed: 0x%x", hr)
    }
    return nil
}
```

### unsafe.Pointer Rules for Syscalls

The conversion from `unsafe.Pointer` to `uintptr` MUST occur in the call expression itself:

```go
// CORRECT: Conversion happens in the call
syscall.Syscall(proc, 1, uintptr(unsafe.Pointer(&data)), 0, 0)

// INCORRECT: uintptr stored in variable first
u := uintptr(unsafe.Pointer(&data))  // GC may move data after this
syscall.Syscall(proc, 1, u, 0, 0)    // data may no longer be at u
```

**Source**: [Gopher Academy - unsafe.Pointer and system calls](https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/)

---

## Existing Go Libraries

### go-ole (github.com/go-ole/go-ole)

The most popular Go library for COM, but it's designed for calling existing COM objects, not implementing COM interfaces.

**Strengths**:
- Pure Go (no CGO)
- Well-tested for calling COM
- Good IUnknown/IDispatch support

**Limitations**:
- Not designed for implementing COM callbacks
- No built-in IDropTarget support

**Source**: [github.com/go-ole/go-ole](https://github.com/go-ole/go-ole)

### Wails combridge (github.com/wailsapp/go-webview2/pkg/combridge)

Used by Wails for WebView2 integration. Provides production-proven patterns for implementing COM interfaces in pure Go.

**Package Structure**:
- `bridge.go` - Core bridge implementation, ComObject type, Resolve function
- `iunknown.go` / `iunknown_impl.go` - IUnknown interface handling
- `syscall.go` - Memory allocation via GlobalAlloc
- `vtables.go` - VTable registration and management

**Key Functions**:
- `RegisterVTable[TParent, T IUnknown](guid string, fns ...interface{})` - Registers vtable methods
- `Resolve[T IUnknown](ifceP uintptr) T` - Resolves Go object from COM pointer
- `ComObject.New[T IUnknown](obj T) *ComObject[T]` - Creates exportable COM object
- `ComObject.Ref() uintptr` - Gets native pointer for COM calls

**Memory Allocation Pattern** (from syscall.go):
```go
// Uses Windows GlobalAlloc for COM-compatible memory
func globalAlloc(dwBytes uintptr) (uintptr, error) {
    ret, _, _ := procGlobalAlloc.Call(uintptr(0), dwBytes)
    if ret == 0 {
        return 0, errors.New("GlobalAlloc failed")
    }
    return ret, nil
}

// Allocates space for uintptr objects (vtable entries)
func allocUintptrObject(count int) (uintptr, []uintptr) {
    size := uintptr(count) * unsafe.Sizeof(uintptr(0))
    ptr, _ := globalAlloc(size)
    // Create slice view of allocated memory
    slice := (*[1 << 30]uintptr)(unsafe.Pointer(ptr))[:count:count]
    return ptr, slice
}
```

**VTable Registration Pattern** (from vtables.go):
```go
func RegisterVTable[TParent, T IUnknown](guid string, fns ...interface{}) {
    // Validate interface hierarchy
    // Copy parent interface function pointers first
    // Append new function pointers
    // Wrap each Go function with windows.NewCallback(fn)
    // Store in thread-safe map by type name
}
```

**Trampoline Pattern**:
```go
// First parameter is always the uintptr of the ComObject
// Use Resolve to get the Go object and redirect the call
func _MyInterfaceMethodTrampoline(this uintptr, arg1, arg2 uintptr) uintptr {
    return combridge.Resolve[MyInterface](this).Method(arg1, arg2)
}
```

**ComObject Lifecycle**:
```go
// Create COM object wrapping a Go object
obj := combridge.New[MyInterface](myGoObject)

// Get pointer for passing to Windows APIs
ptr := obj.Ref()

// Cleanup (reference counted - may not immediately free)
obj.Close()
```

**Key Insight**: combridge uses `GlobalAlloc` (not Go heap) for vtable memory, ensuring Windows can access it safely without Go GC interference.

**Source**: [pkg.go.dev - combridge](https://pkg.go.dev/github.com/wailsapp/go-webview2/pkg/combridge)

### lxn/win (github.com/lxn/win)

Windows API wrapper with some COM support.

### jchv/go-webview2 (github.com/jchv/go-webview2)

WebView2 bindings without CGO. May have useful patterns.

**Source**: [github.com/jchv/go-webview2](https://github.com/jchv/go-webview2)

### rodrigocfd/windigo (github.com/rodrigocfd/windigo)

Comprehensive Windows API and GUI library in pure Go with full COM support including IDropTarget.

**Key Features**:
- 100% pure Go, no CGO
- Full IDropTarget implementation via `ole.NewIDropTargetImpl()`
- Uses `OleReleaser` pattern for memory management (like an arena allocator)
- Type-safe COM creation through `CoCreateInstance`

**IDropTarget Methods**:
```go
// Create new IDropTarget
dropTarget := ole.NewIDropTargetImpl(releaser)

// Set up callbacks
dropTarget.DragEnter(func(dataObj *IDataObject, keyState co.MK,
    pt win.POINT, effect *co.DROPEFFECT) co.HRESULT {
    // Handle drag enter
    return co.HRESULT_S_OK
})

dropTarget.DragOver(func(keyState co.MK, pt win.POINT,
    effect *co.DROPEFFECT) co.HRESULT {
    // Handle drag over
    return co.HRESULT_S_OK
})

dropTarget.DragLeave(func() co.HRESULT {
    // Handle drag leave
    return co.HRESULT_S_OK
})

dropTarget.Drop(func(dataObj *IDataObject, keyState co.MK,
    pt win.POINT, effect *co.DROPEFFECT) co.HRESULT {
    // Handle drop - extract files from dataObj
    return co.HRESULT_S_OK
})

// Register with window
ole.RegisterDragDrop(hwnd, dropTarget)
```

**Important Note**: The windigo documentation states "Windows GUI is single-threaded" and requires `runtime.LockOSThread()` at application startup. It does NOT explicitly address Go issue #20823, so external thread callback issues may still apply.

**Source**: [github.com/rodrigocfd/windigo](https://github.com/rodrigocfd/windigo), [pkg.go.dev/github.com/rodrigocfd/windigo/win/ole](https://pkg.go.dev/github.com/rodrigocfd/windigo/win/ole)

---

## Implementation Approaches

### Approach 1: CGO with import "C"

**Pros**:
- Full COM callback support
- External thread callbacks work correctly

**Cons**:
- Requires C compiler (MinGW)
- Build complexity
- Cross-compilation issues

**Implementation**:
1. Add `import "C"` to force CGO
2. Set up MinGW properly (see below)
3. Implement IDropTarget normally

**MinGW Setup on Windows**:
1. Install MSYS2 (recommended) to `C:\msys64\`
2. Install MinGW-w64 toolchain
3. Add to PATH: `C:\msys64\mingw64\bin`
4. Verify: `gcc -v` should show x86_64-w64-mingw32

**MinGW Configuration Requirements**:
- Architecture: x86_64
- Threads: **posix** (important for thread support)
- Exception: sjlj

**Recommended MinGW Version**: WinLibs port with GCC 13.2.0 (MCF threads) + MinGW-w64 11.0.1 (UCRT)

**Build Command**:
```bash
CGO_ENABLED=1 go build -o razor.exe ./cmd/razor
```

**Cross-Compile from Linux**:
```bash
# Install MinGW on Ubuntu
sudo apt-get install gcc-mingw-w64-x86-64

# Build
GOOS=windows GOARCH=amd64 CGO_ENABLED=1 \
  CC=x86_64-w64-mingw32-gcc \
  CXX=x86_64-w64-mingw32-g++ \
  go build -o razor.exe ./cmd/razor
```

**Known Issue**: Some MinGW versions (especially UCRT-based) can cause linking errors like `undefined reference to '__imp___iob_func'`. If you encounter this, try a different MinGW distribution.

### Approach 2: Wails combridge Pattern

**Pros**:
- Pure Go
- Proven to work in production (Wails)

**Cons**:
- Complex implementation
- May still have external thread issues

**Implementation**:
1. Study combridge source
2. Implement IDropTarget using RegisterVTable
3. Test thoroughly

### Approach 3: Hybrid - CGO Shim

**Pros**:
- Minimal C code
- Main logic in Go

**Cons**:
- Still requires C compiler

**Implementation**:
1. Create minimal C shim that handles external thread setup
2. Call Go code from properly initialized thread

### Approach 4: WM_DROPFILES (Current Fallback)

**Pros**:
- Simple
- No external thread issues (same thread as message loop)
- Works without CGO

**Cons**:
- No hover highlighting during drag
- No DragEnter/DragOver/DragLeave events
- Only notified on actual drop

This is what we're currently using, but it provides degraded UX compared to IDropTarget.

### Approach 5: Use windigo Library

**Pros**:
- Pure Go, no CGO
- Already has IDropTarget implementation
- Well-maintained library
- Handles vtable setup and memory management

**Cons**:
- May still have Go issue #20823 problems (not explicitly addressed)
- Adds dependency
- Would need to integrate with Gio

**Implementation**:
1. Add windigo dependency
2. Use `ole.NewIDropTargetImpl()` to create IDropTarget
3. Register with Gio window HWND
4. Test whether callbacks fire from Explorer drag

### Approach 6: Investigate Windigo Source

If windigo's IDropTarget works, study its source to understand:
1. How it allocates vtables
2. How it handles callback registration
3. Whether it uses any special patterns for external thread support

This could inform our own implementation without adding the full dependency.

---

## Pitfalls and Gotchas

### 1. OleInitialize vs CoInitialize

**ALWAYS** use `OleInitialize`, never `CoInitialize` or `CoInitializeEx`. Using the wrong function causes `RegisterDragDrop` to return `E_OUTOFMEMORY`.

### 2. Thread Affinity

All OLE operations must happen on the same thread that called `OleInitialize`. Use `runtime.LockOSThread()`.

### 3. Message Loop Requirement

The thread with `RegisterDragDrop` must pump messages. Failure causes dragging applications to hang.

### 4. POINTL Parameter Passing on x64

On Windows x64, small structs like POINTL (8 bytes = two int32) are typically passed by value in a single register. This means:

**In Windows x64 ABI**:
- POINTL is passed as a single 64-bit value, NOT as two separate int32 parameters
- The struct is packed: low 32 bits = X, high 32 bits = Y

**Go callback signature considerations**:
```go
// WRONG - Treats X and Y as separate parameters
func DragEnterCallback(this uintptr, pDataObj uintptr, grfKeyState uint32,
    ptX int32, ptY int32, pdwEffect uintptr) uintptr

// POTENTIALLY CORRECT - POINTL as single uintptr
func DragEnterCallback(this uintptr, pDataObj uintptr, grfKeyState uint32,
    pt uintptr, pdwEffect uintptr) uintptr

// To unpack POINTL from uintptr:
func unpackPOINTL(pt uintptr) (x, y int32) {
    x = int32(pt & 0xFFFFFFFF)
    y = int32(pt >> 32)
    return
}
```

**Note**: Go's internal ABI may differ from Windows x64 ABI. When Go creates callbacks via `syscall.NewCallback`, it generates a stub that translates between calling conventions. Test thoroughly!

### 5. GC Moving Memory

Go's GC can move memory. COM pointers stored externally (in Windows) must not move. Solutions:
- Use `GlobalAlloc` for COM memory
- Keep references in global variables
- Use pointer cache maps

### 6. Reference Counting

COM uses reference counting. `RegisterDragDrop` calls `AddRef` on your IDropTarget. You must implement proper ref counting to avoid leaks or premature destruction.

### 7. Callback Return Types

COM methods return `HRESULT` (int32/uint32). Ensure callback functions return the correct type.

### 8. VTable Order

VTable methods MUST be in the exact order specified by the interface definition. Wrong order = wrong methods called = crashes or hangs.

### 9. syscall.Syscall Parameter Count

`syscall.Syscall` takes up to 3 extra parameters, `syscall.Syscall6` takes up to 6, etc. Ensure you're using the right variant.

### 10. Unicode Strings

Windows uses UTF-16. Use `windows.UTF16PtrFromString` and `windows.UTF16ToString` for string conversion.

### 11. DragFinish vs ReleaseStgMedium

**CRITICAL**: Do NOT call both `DragFinish` and `ReleaseStgMedium` on the same data. This causes double-free crashes.

- For **WM_DROPFILES**: Call `DragFinish(hdrop)` to release the HDROP
- For **IDropTarget**: Call `ReleaseStgMedium(&medium)` to release the STGMEDIUM

The windigo documentation explicitly warns: "DragFinish() crashes ReleaseStgMedium(), don't call"

### 12. RevokeDragDrop Timing

`RegisterDragDrop` increments the reference count on your IDropTarget. You **must** call `RevokeDragDrop(hwnd)` before destroying the window or freeing the IDropTarget. Calling it in the destructor is too late and may cause crashes.

```go
// During window close or cleanup
RevokeDragDrop(hwnd)
// THEN free your IDropTarget
```

### 13. Same-Thread Drag Source/Target

If the drag initiator and drop target are on the same thread, there can be issues with IDataObject pointer validity after `DoDragDrop` returns. Test thoroughly if implementing both drag source and drop target.

### 14. DLL Loading Security

Use `windows.NewLazySystemDLL` (from golang.org/x/sys/windows) instead of `syscall.NewLazyDLL` to prevent DLL preloading attacks. The newer function uses `LoadLibraryEx` with `LOAD_LIBRARY_SEARCH_SYSTEM32`.

### 15. Stack Size Limitations

Without CGO, Go has a 64KB stack limit for syscalls. If you're calling complex Windows functions, this might be insufficient. The stack limit increases when CGO is enabled.

### 16. Floating Point Parameters

If any COM method takes float parameters, use proper conversion:
```go
// For C float
uintptr(math.Float32bits(floatVal))

// For C double
uintptr(math.Float64bits(doubleVal))
```

Note: IDropTarget methods don't use floats, but other COM interfaces might.

---

## Sources

### Microsoft Documentation
- [RegisterDragDrop](https://learn.microsoft.com/en-us/windows/win32/api/ole2/nf-ole2-registerdragdrop)
- [IDropTarget Interface](https://learn.microsoft.com/en-us/windows/win32/api/oleidl/nn-oleidl-idroptarget)
- [IDropTarget::DragEnter](https://learn.microsoft.com/en-us/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter)
- [IDropTarget::DragOver](https://learn.microsoft.com/en-us/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover)
- [IDataObject::GetData](https://learn.microsoft.com/en-us/windows/win32/api/objidl/nf-objidl-idataobject-getdata)
- [DragQueryFileW](https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-dragqueryfilew)
- [Shell Clipboard Formats](https://learn.microsoft.com/en-us/windows/win32/shell/clipboard)
- [DROPEFFECT Constants](https://learn.microsoft.com/en-us/windows/win32/com/dropeffect-constants)
- [GlobalAlloc](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globalalloc)
- [POINTL Structure](https://learn.microsoft.com/en-us/windows/win32/api/windef/ns-windef-pointl)

### Go Issues and Documentation
- [golang/go#20823 - syscall.NewCallback thread issue](https://github.com/golang/go/issues/20823)
- [golang/go#9240 - Cannot call Win32 APIs that spawn threads](https://github.com/golang/go/issues/9240)
- [golang/go#6751 - Windows callback on non-Go thread fails](https://github.com/golang/go/issues/6751)
- [Go Wiki - LockOSThread](https://go.dev/wiki/LockOSThread)
- [Go Wiki - cgo](https://go.dev/wiki/cgo)

### Go Libraries
- [go-ole/go-ole](https://github.com/go-ole/go-ole)
- [wailsapp/go-webview2 combridge](https://pkg.go.dev/github.com/wailsapp/go-webview2/pkg/combridge)
- [lxn/win](https://github.com/lxn/win)
- [jchv/go-webview2](https://github.com/jchv/go-webview2)

### Tutorials and Articles
- [Catch22 - Drop Target Tutorial](https://www.catch22.net/tuts/ole/drop-target/)
- [Gopher Academy - unsafe.Pointer and system calls](https://blog.gopheracademy.com/advent-2017/unsafe-pointer-and-system-calls/)
- [Stack Overflow - Call COM object method from Go without CGo](https://stackoverflow.com/questions/39162054/call-com-object-method-from-go-without-cgo)
- [Stack Overflow - Benefits of runtime.LockOSThread](https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang)

### Other Resources
- [pinvoke.net - FORMATETC](https://www.pinvoke.net/default.aspx/Structures/FORMATETC.html)
- [CodeProject - IDropTarget Implementation](https://www.codeproject.com/Articles/840/How-to-Implement-Drag-and-Drop-Between-Your-Progra)
- [Gio PR #111 - macOS DnD support](https://github.com/gioui/gio/pull/111) - Shows Gio's approach to external DnD, Windows support missing

---

## Gio UI Considerations

### Current Gio External DnD Status

Gio has a PR (#111) adding external drag-and-drop for macOS, but Windows support is explicitly missing. The PR author noted they plan to add Windows and Linux support "as soon as I've time to do so."

**Implications for Razor**:
1. We cannot rely on Gio for Windows DnD support in the near term
2. Any solution we implement should be designed to integrate with Gio's event system
3. We may want to contribute our Windows implementation back to Gio

**Source**: [Gio PR #111](https://github.com/gioui/gio/pull/111)

---

## Recommended Next Steps

Based on this research, here are the recommended approaches in order of preference:

### 1. Test windigo's IDropTarget (Low Risk)

**Rationale**: windigo claims to work without CGO and has a complete IDropTarget implementation. If it works with Gio windows, this would be the simplest solution.

**Steps**:
1. Create a minimal test app that uses windigo's IDropTarget with a Gio window
2. Register the drop target with the HWND from Gio's Win32ViewEvent
3. Test if callbacks fire when dragging from Explorer
4. If it works, integrate into Razor

### 2. Study windigo Source Code (Medium Effort)

If windigo works, study how it implements COM callbacks to understand:
- Vtable allocation strategy
- Callback wrapping technique
- Any workarounds for external thread issues

This knowledge could inform a standalone implementation.

### 3. CGO with Proper MinGW Setup (Higher Effort, Full Functionality)

If pure Go approaches fail due to Go issue #20823:
1. Document the exact MinGW setup required
2. Create a minimal CGO shim
3. Test the `import "C"` workaround
4. Set up CI/CD for Windows builds with MinGW

### 4. Continue with WM_DROPFILES (Fallback)

If all else fails, enhance the current WM_DROPFILES implementation:
- Accept the limitation of no hover highlighting
- Focus on making the drop experience as smooth as possible
- Document the limitation for users

---

## Open Questions (With Answers)

### 1. Does windigo's IDropTarget work with Gio windows?

**Status**: UNKNOWN - Requires testing

**What we know**:
- Windigo's documentation states it's "100% pure Go â€“ CGo is not used, just native syscalls"
- It provides `ole.NewIDropTargetImpl()` for creating IDropTarget
- It requires `runtime.LockOSThread()` at application startup

**Concern**: Windigo does NOT explicitly address Go issue #20823. Since OLE drag-drop callbacks come from Windows Explorer's external thread, this may still fail without CGO.

**Next Step**: Create minimal test app:
```go
package main

import "C"  // Try with and without this

import (
    "runtime"
    "github.com/rodrigocfd/windigo/win"
    "github.com/rodrigocfd/windigo/win/ole"
)

func main() {
    runtime.LockOSThread()
    // ... test with Gio window HWND
}
```

### 2. Is Go issue #20823 ever getting fixed?

**Status**: CLOSED (FrozenDueToAge) - No fix planned

**Details**:
- Issue opened: June 28, 2017
- Status: Closed and frozen
- The issue is marked as duplicate of frozen issue #9240

**Technical reason**: `syscall.NewCallback` uses `runtime.cgocallback_gofunc` internally, which creates a new "m" (machine) for callbacks on new threads - but only if CGO is initialized.

**Official workaround**: Import `"C"` package:
```go
import "C"  // This alone enables external thread callbacks
```

**Implication for Razor**: We cannot expect a standard library fix. We must either:
- Accept the CGO dependency
- Find a pure-Go library that has solved this differently
- Use a degraded experience (WM_DROPFILES only)

**Source**: [golang/go#20823](https://github.com/golang/go/issues/20823)

### 3. Will Gio add native Windows DnD support?

**Status**: PR #111 exists for macOS, Windows NOT implemented

**Details**:
- PR #111 adds macOS external drag-and-drop
- Author stated intent to add Windows/Linux "as soon as I've time"
- No timeline or active development visible

**Our options**:
1. Wait for Gio to add Windows support (uncertain timeline)
2. Implement it ourselves and contribute upstream
3. Work around using WM_DROPFILES or our own IDropTarget

**Source**: [gioui/gio PR #111](https://github.com/gioui/gio/pull/111)

### 4. Can we detect when OLE drag starts?

**Status**: PARTIALLY POSSIBLE

**Methods to investigate**:

1. **WM_ENTERIDLE**: Sent when a modal dialog box or menu enters an idle state - not directly applicable

2. **SetWindowsHookEx with WH_MOUSE_LL**: Could detect mouse drag start, but:
   - Still need IDropTarget for actual drop data
   - Adds complexity for partial benefit

3. **DragDetect function**: Determines if drag operation should begin based on mouse position changes
   - Typically used by drag SOURCE, not target
   - Not useful for detecting external drags

4. **TrackMouseEvent**: Can track mouse leave/hover but not drag state

**Conclusion**: There's no reliable way to detect external OLE drag operations without implementing IDropTarget. The OS doesn't provide a "drag is happening" notification to non-participating windows.

**Implication**: WM_DROPFILES remains our best fallback - it works without knowing about drag-over, we just miss the hover highlighting.

---

## Test Plan for windigo IDropTarget

To answer question #1 definitively, here's a test plan:

### Minimal Test (test_windigo_droptarget.go)

```go
//go:build windows

package main

// import "C"  // Uncomment to test with CGO enabled

import (
    "fmt"
    "runtime"

    "gioui.org/app"
    "github.com/rodrigocfd/windigo/win"
    "github.com/rodrigocfd/windigo/win/co"
    "github.com/rodrigocfd/windigo/win/ole"
)

func main() {
    runtime.LockOSThread()

    go func() {
        w := new(app.Window)

        for e := range w.Events() {
            switch evt := e.(type) {
            case app.Win32ViewEvent:
                if evt.Valid() {
                    testDropTarget(evt.HWND)
                }
            }
        }
    }()

    app.Main()
}

func testDropTarget(hwnd uintptr) {
    rel := ole.NewReleaser()
    defer rel.Release()

    dropTarget := ole.NewIDropTargetImpl(rel)

    dropTarget.DragEnter(func(dataObj *ole.IDataObject, keyState co.MK,
        pt win.POINT, effect *co.DROPEFFECT) co.HRESULT {
        fmt.Println("DragEnter called!")  // Will this print?
        *effect = co.DROPEFFECT_COPY
        return co.HRESULT_S_OK
    })

    dropTarget.Drop(func(dataObj *ole.IDataObject, keyState co.MK,
        pt win.POINT, effect *co.DROPEFFECT) co.HRESULT {
        fmt.Println("Drop called!")
        return co.HRESULT_S_OK
    })

    // Register with the Gio window
    ole.RegisterDragDrop(win.HWND(hwnd), dropTarget)

    fmt.Println("Drop target registered, try dragging a file...")
}
```

### Expected Outcomes

| Test Case | Expected Result | Actual Result |
|-----------|-----------------|---------------|
| Without `import "C"` | Hang/crash on DragEnter | TBD |
| With `import "C"` | DragEnter prints, Drop works | TBD |

### Test Commands

```bash
# Test 1: Without CGO
go build -o test_no_cgo.exe test_windigo_droptarget.go
./test_no_cgo.exe

# Test 2: With CGO (uncomment import "C")
CGO_ENABLED=1 go build -o test_cgo.exe test_windigo_droptarget.go
./test_cgo.exe
```

This test will definitively answer whether windigo solves the external thread problem or still requires CGO.

---

## Alternative Approaches to Windows API Calls in Go

This section documents alternative patterns for calling Windows APIs from Go, based on research from various sources including the AnubisSec article.

**Source**: [AnubisSec - How To Call Windows APIs In Golang](https://anubissec.github.io/How-To-Call-Windows-APIs-In-Golang/)

### Using golang.org/x/sys/windows

The `golang.org/x/sys/windows` package provides a cleaner API than the raw `syscall` package:

```go
import "golang.org/x/sys/windows"

var (
    user32DLL           = windows.NewLazyDLL("user32.dll")
    procSystemParamInfo = user32DLL.NewProc("SystemParametersInfoW")
)

func ChangeWallpaper(imagePath string) error {
    pathPtr, err := windows.UTF16PtrFromString(imagePath)
    if err != nil {
        return err
    }

    // SPI_SETDESKWALLPAPER = 0x0014, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE = 0x001A
    ret, _, err := procSystemParamInfo.Call(
        0x0014,
        0,
        uintptr(unsafe.Pointer(pathPtr)),
        0x001A,
    )

    if ret == 0 {
        return err
    }
    return nil
}
```

### String Conversion Patterns

Windows APIs require UTF-16 strings. The key conversion functions:

```go
// UTF-16 for most Windows APIs (W suffix functions)
ptr, err := windows.UTF16PtrFromString("my string")
if err != nil {
    // Handle error (string contains NUL)
}

// Converting back from UTF-16
goString := windows.UTF16ToString(utf16Slice)

// For ANSI functions (A suffix) - rarely needed
ansiBytes := append([]byte("my string"), 0) // null-terminated
ansiPtr := &ansiBytes[0]
```

### Memory Management with unsafe.Pointer

The pattern for passing Go data to Windows APIs:

```go
// 1. Convert to *uint16 for strings
pathPtr, _ := windows.UTF16PtrFromString(path)

// 2. Wrap in unsafe.Pointer
unsafePtr := unsafe.Pointer(pathPtr)

// 3. Convert to uintptr IN THE CALL (critical!)
someWindowsFunc.Call(uintptr(unsafePtr))

// WRONG - never store uintptr before the call:
badPtr := uintptr(unsafePtr)  // GC can move the string after this!
someWindowsFunc.Call(badPtr)  // May point to invalid memory
```

### Why This Matters for IDropTarget

Understanding these patterns is essential because:

1. **File paths from CF_HDROP** come as UTF-16 - need `windows.UTF16ToString`
2. **COM string returns** (like BSTR) need proper conversion
3. **Memory lifetime** - COM callbacks happen on external threads, Go GC rules still apply
4. **Pointer safety** - all the unsafe.Pointer rules apply to COM interface pointers

---

## COM Object Memory Layout In Depth

This section provides detailed analysis of COM object memory layout, essential for understanding how to correctly implement COM interfaces in Go.

**Source**: [Raymond Chen - The layout of a COM object](https://devblogs.microsoft.com/oldnewthing/20040205-00/?p=40733)

### The Fundamental Structure

A COM interface pointer is **not** a pointer to an object. It's a pointer to a vtable pointer:

```
Your pointer (p)
    â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ lpVtbl â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”‚
    â”‚ m_refCount  â”‚          â†“
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ m_data      â”‚    â”‚ QueryInterface    â”‚ â† Index 0
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                       â”‚ AddRef            â”‚ â† Index 1
                       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                       â”‚ Release           â”‚ â† Index 2
                       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                       â”‚ Method1           â”‚ â† Index 3
                       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                       â”‚ Method2           â”‚ â† Index 4
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why This Layout Matters

In Go, when implementing a COM object:

```go
// The Go object must have the vtable pointer as its FIRST field
type DropTarget struct {
    vtbl       *IDropTargetVtbl  // MUST be first!
    refCount   int32
    hwnd       uintptr
    allowDrop  bool
    dataObject uintptr
}
```

When Windows calls `IDropTarget::DragEnter`, it:
1. Takes the interface pointer (pointing to our struct)
2. Reads the first field (vtbl pointer)
3. Indexes into that vtable at position 3 (DragEnter)
4. Calls the function at that address with `this` = the original pointer

### Multiple Interface Implementation

A single Go object can implement multiple COM interfaces by having multiple vtable pointers:

```go
type MyComplexObject struct {
    vtblDropTarget  *IDropTargetVtbl  // p points here for IDropTarget
    vtblDropSource  *IDropSourceVtbl  // q points here for IDropSource
    vtblDataObject  *IDataObjectVtbl  // r points here for IDataObject
    // common data...
    refCount int32
}
```

When `QueryInterface` is called for different IIDs:
- For `IID_IDropTarget`: return pointer to start of struct
- For `IID_IDropSource`: return pointer offset by `unsafe.Sizeof(uintptr(0))`
- For `IID_IDataObject`: return pointer offset by `2 * unsafe.Sizeof(uintptr(0))`

### The `this` Pointer in Callbacks

Every COM method receives `this` as its first parameter. In Go callbacks:

```go
func dragEnterCallback(this uintptr, pDataObj uintptr, grfKeyState uint32,
    pt uintptr, pdwEffect uintptr) uintptr {

    // Convert 'this' back to our Go struct
    dt := (*DropTarget)(unsafe.Pointer(this))

    // Now we can access our fields
    dt.allowDrop = checkDataObject(pDataObj)
    dt.dataObject = pDataObj  // Cache for DragOver

    // ... rest of implementation
    return S_OK
}
```

### VTable Function Pointer Types

Each vtable entry is a function pointer. In Go, we create these with `syscall.NewCallback`:

```go
vtable := &IDropTargetVtbl{
    QueryInterface: syscall.NewCallback(queryInterfaceFunc),
    AddRef:         syscall.NewCallback(addRefFunc),
    Release:        syscall.NewCallback(releaseFunc),
    DragEnter:      syscall.NewCallback(dragEnterFunc),
    DragOver:       syscall.NewCallback(dragOverFunc),
    DragLeave:      syscall.NewCallback(dragLeaveFunc),
    Drop:           syscall.NewCallback(dropFunc),
}
```

### Memory Stability Requirements

The vtable memory **must not move**. Options:

1. **Global variable** - simplest, vtable never moves:
```go
var globalVtable = IDropTargetVtbl{...}  // In package scope
```

2. **GlobalAlloc** - Windows-managed memory:
```go
ptr := GlobalAlloc(GPTR, unsafe.Sizeof(IDropTargetVtbl{}))
vtbl := (*IDropTargetVtbl)(unsafe.Pointer(ptr))
// Fill in vtbl fields...
```

3. **Keep reference** - prevent GC collection:
```go
var pointerCache = make(map[uintptr]*DropTarget)
```

---

## C++ IDropTarget Reference Implementation

This section provides complete C++ reference implementations to understand the underlying patterns. Understanding the C++ implementation helps when translating to Go.

**Sources**:
- [Catch22.net - Drop Target Tutorial](https://www.catch22.net/tuts/ole/drop-target/)
- [CodeProject - Drag and Drop Between Your Program and Explorer](https://www.codeproject.com/Articles/840/How-to-Implement-Drag-and-Drop-Between-Your-Progra)

### Complete C++ Class Definition

```cpp
class CDropTarget : public IDropTarget
{
public:
    // IUnknown implementation
    HRESULT __stdcall QueryInterface(REFIID iid, void **ppvObject)
    {
        if (iid == IID_IUnknown || iid == IID_IDropTarget)
        {
            *ppvObject = static_cast<IDropTarget*>(this);
            AddRef();
            return S_OK;
        }
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    ULONG __stdcall AddRef(void)
    {
        return InterlockedIncrement(&m_lRefCount);
    }

    ULONG __stdcall Release(void)
    {
        LONG count = InterlockedDecrement(&m_lRefCount);
        if (count == 0)
        {
            delete this;
        }
        return count;
    }

    // IDropTarget implementation
    HRESULT __stdcall DragEnter(IDataObject *pDataObject, DWORD grfKeyState,
                                POINTL pt, DWORD *pdwEffect)
    {
        // Check if we can accept this data format
        m_fAllowDrop = QueryDataObject(pDataObject);

        if (m_fAllowDrop)
        {
            *pdwEffect = DropEffect(grfKeyState, pt, *pdwEffect);
            SetFocus(m_hWnd);  // Optional: provide visual feedback
        }
        else
        {
            *pdwEffect = DROPEFFECT_NONE;
        }

        return S_OK;
    }

    HRESULT __stdcall DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
    {
        if (m_fAllowDrop)
        {
            *pdwEffect = DropEffect(grfKeyState, pt, *pdwEffect);
        }
        else
        {
            *pdwEffect = DROPEFFECT_NONE;
        }
        return S_OK;
    }

    HRESULT __stdcall DragLeave(void)
    {
        m_fAllowDrop = false;
        return S_OK;
    }

    HRESULT __stdcall Drop(IDataObject *pDataObject, DWORD grfKeyState,
                           POINTL pt, DWORD *pdwEffect)
    {
        if (m_fAllowDrop)
        {
            DropData(m_hWnd, pDataObject);
            *pdwEffect = DropEffect(grfKeyState, pt, *pdwEffect);
        }
        else
        {
            *pdwEffect = DROPEFFECT_NONE;
        }
        return S_OK;
    }

    CDropTarget(HWND hwnd) : m_lRefCount(1), m_hWnd(hwnd), m_fAllowDrop(false) {}

private:
    LONG  m_lRefCount;
    HWND  m_hWnd;
    bool  m_fAllowDrop;

    // Helper: Check if data object contains CF_HDROP
    bool QueryDataObject(IDataObject *pDataObject)
    {
        FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        return pDataObject->QueryGetData(&fmtetc) == S_OK;
    }

    // Helper: Calculate drop effect based on keyboard modifiers
    DWORD DropEffect(DWORD grfKeyState, POINTL pt, DWORD dwAllowed)
    {
        DWORD dwEffect = 0;

        // Check keyboard modifiers
        if (grfKeyState & MK_CONTROL)
        {
            dwEffect = grfKeyState & MK_SHIFT ? DROPEFFECT_LINK : DROPEFFECT_COPY;
        }
        else if (grfKeyState & MK_SHIFT)
        {
            dwEffect = DROPEFFECT_MOVE;
        }

        // Default effect if no modifier
        if (dwEffect == 0)
        {
            if (dwAllowed & DROPEFFECT_COPY) dwEffect = DROPEFFECT_COPY;
            if (dwAllowed & DROPEFFECT_MOVE) dwEffect = DROPEFFECT_MOVE;
        }

        return dwEffect & dwAllowed;
    }

    // Helper: Extract files from data object
    void DropData(HWND hwnd, IDataObject *pDataObject)
    {
        FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
        STGMEDIUM stgmed;

        if (pDataObject->GetData(&fmtetc, &stgmed) == S_OK)
        {
            HDROP hdrop = (HDROP)GlobalLock(stgmed.hGlobal);

            if (hdrop != NULL)
            {
                UINT numFiles = DragQueryFile(hdrop, 0xFFFFFFFF, NULL, 0);

                for (UINT i = 0; i < numFiles; i++)
                {
                    TCHAR szFile[MAX_PATH];
                    if (DragQueryFile(hdrop, i, szFile, MAX_PATH) > 0)
                    {
                        // Process file: szFile
                        // In real code, notify your application here
                    }
                }

                GlobalUnlock(stgmed.hGlobal);
            }

            // CRITICAL: Release the storage medium, NOT DragFinish!
            ReleaseStgMedium(&stgmed);
        }
    }
};
```

### Registration and Cleanup in C++

```cpp
// At window creation time
CDropTarget *pDropTarget = new CDropTarget(hwnd);
OleInitialize(NULL);  // MUST be OleInitialize, not CoInitialize!
RegisterDragDrop(hwnd, pDropTarget);
pDropTarget->Release();  // RegisterDragDrop calls AddRef

// At window destruction time (WM_DESTROY)
RevokeDragDrop(hwnd);  // MUST call before window is destroyed
OleUninitialize();
```

### Key Observations for Go Translation

1. **Reference counting**: C++ uses `InterlockedIncrement/Decrement` - Go should use `sync/atomic`
2. **Calling convention**: `__stdcall` matches what `syscall.NewCallback` expects on Windows
3. **Memory access**: C++ can directly cast `HGLOBAL` to `HDROP` after `GlobalLock`
4. **Error handling**: Return `HRESULT` values, not exceptions

---

## FORMATETC and STGMEDIUM Memory Structures

Deep dive into the memory structures used in OLE data transfer.

**Sources**:
- [FlyLib - FORMATETC and STGMEDIUM Structures](https://flylib.com/books/en/1.563.1.211/1/)
- [Tenouk - The FORMATETC Structure](https://www.tenouk.com/visualcplusmfc/mfcsupp/formatetc.html)

### FORMATETC Structure Layout

```cpp
// C/C++ definition
typedef struct tagFORMATETC {
    CLIPFORMAT      cfFormat;   // Clipboard format ID
    DVTARGETDEVICE* ptd;        // Target device (usually NULL)
    DWORD           dwAspect;   // Aspect of data (content, thumbnail, etc.)
    LONG            lindex;     // Part of data (-1 for all)
    DWORD           tymed;      // Storage medium type
} FORMATETC;
```

```go
// Go equivalent
type FORMATETC struct {
    CfFormat uint16   // 2 bytes - Clipboard format (CF_HDROP = 15)
    _        [2]byte  // 2 bytes padding (alignment)
    Ptd      uintptr  // 8 bytes on x64 - DVTARGETDEVICE pointer (usually 0)
    DwAspect uint32   // 4 bytes - DVASPECT_CONTENT = 1
    Lindex   int32    // 4 bytes - -1 for all data
    Tymed    uint32   // 4 bytes - TYMED_HGLOBAL = 1
    _        [4]byte  // 4 bytes padding (alignment to 8 bytes)
}
// Total size on x64: 32 bytes
```

### FORMATETC Field Details

| Field | Type | Common Values | Description |
|-------|------|---------------|-------------|
| `cfFormat` | CLIPFORMAT (uint16) | CF_HDROP=15, CF_TEXT=1, CF_UNICODETEXT=13 | Identifies the data format |
| `ptd` | DVTARGETDEVICE* | NULL (0) | Device-specific rendering; usually NULL |
| `dwAspect` | DWORD | DVASPECT_CONTENT=1 | How data should be rendered |
| `lindex` | LONG | -1 | Which part of data; -1 means all |
| `tymed` | DWORD | TYMED_HGLOBAL=1, TYMED_FILE=2 | Storage medium type |

### STGMEDIUM Structure Layout

```cpp
// C/C++ definition
typedef struct tagSTGMEDIUM {
    DWORD    tymed;           // Storage medium type
    union {
        HBITMAP       hBitmap;
        HMETAFILEPICT hMetaFilePict;
        HENHMETAFILE  hEnhMetaFile;
        HGLOBAL       hGlobal;      // Most common for file drops
        LPOLESTR      lpszFileName;
        IStream*      pstm;
        IStorage*     pstg;
    };
    IUnknown* pUnkForRelease;  // Object responsible for releasing
} STGMEDIUM;
```

```go
// Go equivalent
type STGMEDIUM struct {
    Tymed          uint32   // 4 bytes - Storage medium type
    _              [4]byte  // 4 bytes padding
    Data           uintptr  // 8 bytes - Union: hGlobal, pstm, etc.
    PUnkForRelease uintptr  // 8 bytes - IUnknown* for releasing (can be 0)
}
// Total size on x64: 24 bytes
```

### STGMEDIUM Union Interpretation

The `Data` field is a union. Interpretation depends on `Tymed`:

| Tymed Value | Constant | Data Contains |
|-------------|----------|---------------|
| 1 | TYMED_HGLOBAL | HGLOBAL (global memory handle) |
| 2 | TYMED_FILE | LPOLESTR (file path) |
| 4 | TYMED_ISTREAM | IStream* |
| 8 | TYMED_ISTORAGE | IStorage* |
| 16 | TYMED_GDI | HBITMAP |
| 32 | TYMED_MFPICT | HMETAFILEPICT |
| 64 | TYMED_ENHMF | HENHMETAFILE |

For file drops, we always use `TYMED_HGLOBAL` (1).

### Working with HGLOBAL Data

When `Tymed` is `TYMED_HGLOBAL`, the `Data` field contains a handle to global memory. To access it:

```cpp
// C++ pattern
HGLOBAL hGlobal = stgmedium.hGlobal;
void* pData = GlobalLock(hGlobal);  // Lock and get pointer
// ... use pData ...
GlobalUnlock(hGlobal);
```

```go
// Go equivalent
var (
    kernel32        = windows.NewLazySystemDLL("kernel32.dll")
    procGlobalLock  = kernel32.NewProc("GlobalLock")
    procGlobalUnlock = kernel32.NewProc("GlobalUnlock")
)

func GlobalLock(hMem uintptr) uintptr {
    ptr, _, _ := procGlobalLock.Call(hMem)
    return ptr
}

func GlobalUnlock(hMem uintptr) {
    procGlobalUnlock.Call(hMem)
}

// Usage:
ptr := GlobalLock(stgmedium.Data)
if ptr != 0 {
    defer GlobalUnlock(stgmedium.Data)
    // Access data via ptr
}
```

### CF_HDROP Memory Layout

When the format is CF_HDROP, the global memory contains a DROPFILES structure followed by file paths:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DROPFILES Structure (20 bytes on x86, 24 on x64)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ pFiles: DWORD    - Offset to file list from start       â”‚
â”‚ pt: POINT        - Drop point (x, y)                    â”‚
â”‚ fNC: BOOL        - Non-client area flag                 â”‚
â”‚ fWide: BOOL      - TRUE if Unicode strings              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ File 1: "C:\path\to\file1.txt\0"  (null-terminated)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ File 2: "C:\path\to\file2.txt\0"  (null-terminated)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ... more files ...                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Final null terminator: "\0"                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```go
// Go structure
type DROPFILES struct {
    PFiles uint32  // Offset in bytes to start of file list
    Pt     POINT   // Drop point
    FNC    int32   // TRUE if on non-client area
    FWide  int32   // TRUE if Unicode
}

type POINT struct {
    X int32
    Y int32
}
```

### Initialization Macro (C++)

A convenient macro for FORMATETC initialization:

```cpp
#define SETFORMATETC(fe, cf, asp, td, med, li) \
    ((fe).cfFormat = cf,   \
     (fe).dwAspect = asp,  \
     (fe).ptd = td,        \
     (fe).tymed = med,     \
     (fe).lindex = li)

// Usage:
FORMATETC fmtetc;
SETFORMATETC(fmtetc, CF_HDROP, DVASPECT_CONTENT, NULL, TYMED_HGLOBAL, -1);
```

### Go Helper Function

```go
// NewFORMATETC creates a FORMATETC for the specified clipboard format
func NewFORMATETC(cfFormat uint16) FORMATETC {
    return FORMATETC{
        CfFormat: cfFormat,
        Ptd:      0,                 // No target device
        DwAspect: DVASPECT_CONTENT,  // 1
        Lindex:   -1,                // All data
        Tymed:    TYMED_HGLOBAL,     // 1
    }
}

// For file drops:
formatetc := NewFORMATETC(CF_HDROP)  // CF_HDROP = 15
```

### Memory Management Rules

1. **After GetData succeeds**:
   - You receive ownership of the STGMEDIUM
   - You MUST call `ReleaseStgMedium(&stgmedium)` when done
   - Do NOT call `DragFinish` (that's only for WM_DROPFILES)

2. **If pUnkForRelease is non-NULL**:
   - The object at that pointer is responsible for freeing
   - `ReleaseStgMedium` will call `pUnkForRelease->Release()`

3. **If pUnkForRelease is NULL**:
   - Caller is responsible for freeing
   - `ReleaseStgMedium` will call the appropriate free function based on `tymed`
   - For TYMED_HGLOBAL: calls `GlobalFree`

### Complete Go Example: Extract Files from IDataObject

```go
func ExtractFilesFromDataObject(pDataObj uintptr) ([]string, error) {
    // Prepare FORMATETC for CF_HDROP
    formatetc := FORMATETC{
        CfFormat: CF_HDROP,          // 15
        Ptd:      0,
        DwAspect: DVASPECT_CONTENT,  // 1
        Lindex:   -1,
        Tymed:    TYMED_HGLOBAL,     // 1
    }

    // Query if format is available
    if !QueryGetData(pDataObj, &formatetc) {
        return nil, fmt.Errorf("CF_HDROP format not available")
    }

    // Get the data
    var stgmedium STGMEDIUM
    if err := GetData(pDataObj, &formatetc, &stgmedium); err != nil {
        return nil, err
    }

    // CRITICAL: Always release when done
    defer ReleaseStgMedium(&stgmedium)

    // Lock global memory to access HDROP
    hdrop := GlobalLock(stgmedium.Data)
    if hdrop == 0 {
        return nil, fmt.Errorf("GlobalLock failed")
    }
    defer GlobalUnlock(stgmedium.Data)

    // Get file count
    count := DragQueryFileCount(hdrop)
    if count == 0 {
        return nil, nil
    }

    // Extract each file path
    paths := make([]string, count)
    for i := uint32(0); i < count; i++ {
        paths[i] = DragQueryFile(hdrop, i)
    }

    return paths, nil
}
```

---

## Additional Sources Added

### Alternative Windows API Patterns
- [AnubisSec - How To Call Windows APIs In Golang](https://anubissec.github.io/How-To-Call-Windows-APIs-In-Golang/)

### COM Memory Layout
- [Raymond Chen - The layout of a COM object](https://devblogs.microsoft.com/oldnewthing/20040205-00/?p=40733)

### C++ Implementation References
- [CodeProject - How to Implement Drag and Drop Between Your Program and Explorer](https://www.codeproject.com/Articles/840/How-to-Implement-Drag-and-Drop-Between-Your-Progra)
- [Stack Overflow - Typical Win32 file drop implementation](https://stackoverflow.com/questions/6148055/typical-win32-file-drop-idroptargetdrop-implementation)
- [C++ IDropTarget Examples - HotExamples](https://cpp.hotexamples.com/examples/-/IDropTarget/DragEnter/cpp-idroptarget-dragenter-method-examples.html)

### Structure Documentation
- [FlyLib - FORMATETC and STGMEDIUM Structures](https://flylib.com/books/en/1.563.1.211/1/)
- [Tenouk - The FORMATETC Structure](https://www.tenouk.com/visualcplusmfc/mfcsupp/formatetc.html)
