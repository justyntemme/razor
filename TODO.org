#+TITLE: Razor File Manager - Project Status
#+AUTHOR: justyntemme
#+DATE: 2024

* Completed Features
** DONE Background Right-Click Menu
   CLOSED: [2024-11-29]
   - [X] Right-click on empty space in file list shows context menu
   - [X] Background menu shows: New File, New Folder, Paste (if clipboard has content)
   - [X] Works in empty directories
   - [X] File-specific options (Copy, Cut, Delete, etc.) only shown for file/folder clicks

** DONE Path Navigation Bug Fix
   CLOSED: [2024-11-29]
   - [X] Handle ~ for home directory
   - [X] Handle ~/path tilde expansion
   - [X] Handle absolute Unix paths (/usr/bin)
   - [X] Handle relative paths (../, ./)
   - [X] Handle Windows drive letters (C:\, D:\)
   - [X] Handle UNC paths (\\server\share)
   - [X] Validate paths before navigation

** DONE Create New File/Folder Dialog
   CLOSED: [2024-11-29]
   - [X] Add "New File" to right-click context menu
   - [X] Add "New Folder" to right-click context menu
   - [X] Keyboard shortcuts (Ctrl+N file, Ctrl+Shift+N folder)
   - [X] Modal dialog with text input
   - [X] Validation (prevent duplicates)
   - [X] Refresh directory after creation

** DONE Open With Support
   CLOSED: [2024-11-29]
   - [X] Linux: xdg-open, kde-open5, gio support
   - [X] macOS: open command, Finder reveal
   - [X] Windows: ShellExecuteW, rundll32 OpenAs_RunDLL
   - [X] Add "Open With..." to context menu (files only)

** DONE Search Improvements
   CLOSED: [2024-11-29]
   - [X] Search-as-you-type for simple filename searches
   - [X] Directives (contents:, ext:, size:, modified:, filename:) require Enter
   - [X] Clear button (X) appears when search active or showing results
   - [X] Clicking X clears search and restores directory
   - [X] "Search Results" badge shows when viewing search results
   - [X] Progress indicator for directive searches (not just contents:)
   - [X] Proper state tracking (IsSearchResult, SearchQuery in State)
   - [X] Fix bug where empty search didn't restore contents
   - [X] Fix race condition: generation counter prevents stale results
   - [X] Stale search results no longer overwrite directory after clear
   - [X] Visual directive pills: recognized directives shown as colored tags
   - [X] Color-coded pills: contents=orange, ext=green, size=blue, modified=pink
   - [X] Placeholder changes to "press Enter to search" when directives detected
   - [X] Fix: typing directive prefix (e.g., "contents:") no longer triggers search
   - [X] Fix: incomplete directives (no value after colon) are rejected
   - [X] Added hasCompleteDirective() and isIncompleteDirective() validation
   - [X] ARCHITECTURE FIX: Separate dirEntries (canonical) from rawEntries (display)
   - [X] Search results only overwrite rawEntries, never dirEntries
   - [X] Directive detection restores directory from cache immediately
   - [X] directiveRestored flag prevents redundant restore calls
   - [X] Gen counter incremented on restore to invalidate pending results
   - [X] FIX: Default search depth now 1 (current dir only)
   - [X] Added recursive: directive for deep search (recursive:N for depth N)
   - [X] Added depth: alias for recursive:
   - [X] Progress bar now updates during content search via ProgressChan
   - [X] Yellow pill color for recursive/depth directives
   - [X] SEARCH CANCELLATION: Clicking X now cancels ongoing searches
   - [X] Context-based cancellation using context.Context
   - [X] Skip system directories (/dev, /proc, /sys, /run, etc.)
   - [X] Skip non-regular files (devices, sockets, etc.)
   - [X] Graceful handling of permission errors (skip instead of fail)
   - [X] FIX: Search runs in goroutine to allow cancel processing
   - [X] FIX: FetchDir cancels any running search
   - [X] Context-aware content reading with chunked I/O
   - [X] Binary file detection (skip files with null bytes)

** DONE Search Engine Integration
   CLOSED: [2024-11-29]
   - [X] Detect available search engines (ripgrep, ugrep)
   - [X] Settings dropdown shows installed engines with versions
   - [X] Unavailable engines shown greyed out (not selectable)
   - [X] Engine selection persisted in Renderer state
   - [X] External engine support for contents: directive
   - [X] ripgrep integration with --files-with-matches
   - [X] ugrep integration with -l flag and -r for recursion
   - [X] External results combined with other directive filters
   - [X] Fallback to builtin on external engine error
   - [X] FIX: ugrep now uses -r flag for recursive search
   - [X] FIX: Depth mapping corrected (our depth=1 = tool depth=0)
   - [X] Streaming progress during external search ("Found X files...")
   - [X] Debug logging for external search commands
   - [X] Indeterminate progress bar (animated sliding bar) for external search
   - [X] Search engine setting saved to database (persists across restarts)

** DONE Rename File/Folder
   CLOSED: [2024-11-29]
   - [X] Add "Rename" to context menu
   - [X] Inline editing in file list
   - [X] Keyboard shortcut (F2)
   - [X] Validation (prevent duplicates, invalid chars)

** DONE Theme Settings
   CLOSED: [2024-11-29]
   - [X] Light/Dark theme toggle in settings
   - [X] Theme preference saved to database
   - [X] Theme applied on startup

* In Progress
** TODO Drag and Drop (On Hold)
   - [ ] Drag files to move
   - [ ] Drag to folders to move into
   - [ ] Ctrl+drag to copy
   - [ ] Visual feedback during drag
   Note: Put on hold due to implementation challenges with Gio

* Next Steps (Priority Order)
** TODO PRIORITY 1: Config.json for UI/Settings Configuration
   Migrate user preferences from SQLite to config.json for deep UI customization.
   Keep SQLite for data that benefits from querying (history, cache, favorites).
   This is prerequisite for Composable UI features.

*** Config file location:
    - Linux/macOS: ~/.config/razor/config.json
    - Windows: %APPDATA%\razor\config.json

*** Config.json Structure:
    #+BEGIN_SRC json
    {
      "ui": {
        "theme": "light",
        "sidebar": {
          "layout": "tabbed",
          "width": 200,
          "position": "left",
          "showFavorites": true,
          "showDrives": true,
          "collapsible": true
        },
        "toolbar": {
          "visible": true,
          "position": "top",
          "showLabels": false
        },
        "fileList": {
          "showDotfiles": false,
          "defaultSort": "name",
          "sortAscending": true,
          "rowHeight": "normal",
          "showIcons": true
        },
        "statusBar": {
          "visible": true,
          "showFileCount": true,
          "showSelectionInfo": true
        }
      },
      "search": {
        "engine": "builtin",
        "defaultDepth": 2,
        "rememberLastQuery": false
      },
      "behavior": {
        "confirmDelete": true,
        "doubleClickToOpen": true,
        "restoreLastPath": true,
        "singleClickToSelect": true
      },
      "tabs": {
        "enabled": false,
        "newTabLocation": "current",
        "lastTabBehavior": "close_app",
        "restoreTabsOnStart": false
      },
      "panels": {
        "preview": {
          "enabled": false,
          "position": "right",
          "width": 300
        },
        "terminal": {
          "enabled": false,
          "position": "bottom",
          "height": 200
        }
      }
    }
    #+END_SRC

*** Architecture Rationale:
    Config.json and SQLite serve DIFFERENT purposes - do NOT sync between them:
    - config.json = User-editable settings (static configuration)
    - SQLite = Application-managed data (dynamic, queryable data)

    Why NOT to read config.json into DB:
    - Redundancy: Same data in two places creates sync issues
    - File editing risk: Manual config.json edits lost if user forgets to "sync"
    - Unnecessary complexity: Sync logic, conflict resolution, hotkeys - all overhead

    Correct approach:
    - config.json is THE source of truth for settings
    - Load on startup, optionally hot-reload on file change (fsnotify)
    - SQLite never stores anything from config.json

*** Implementation:
    - Create internal/config package for JSON config handling
    - Load config on startup, create default if not exists
    - Remove settings from store.DB (keep schema for future use)
    - Settings UI reads/writes to config.json
    - Hot-reload config changes using fsnotify (or require app restart)
    - Validation and schema versioning

*** Keep in SQLite (store.DB) for future features:
    - Favorites (queryable, groupable)
    - Search history (searchable, limitable)
    - Recent files/directories (queryable by date, path)
    - File tags/labels (many-to-many relationships)
    - Custom file associations
    - Cached thumbnails metadata

** TODO PRIORITY 2: Composable Sidebar UI
   Make the sidebar layout configurable, allowing users to choose between:
   - Tabbed view (Favorites | Drives tabs) - current implementation
   - Stacked view (Favorites above Drives with separator) - original design
   - Favorites only / Drives only options

*** Implementation:
    - Create SidebarConfig struct with layout options
    - Implement sidebar layout variants as composable functions
    - Read sidebar layout preference from config.json
    - Settings UI to switch between layouts

*** SidebarConfig Structure:
    #+BEGIN_SRC go
    type SidebarConfig struct {
        Layout            string // "tabbed" | "stacked" | "favorites_only" | "drives_only"
        Width             int    // sidebar width in dp
        Position          string // "left" | "right"
        ShowFavorites     bool
        ShowDrives        bool
        FavoritesPosition string // "top" | "bottom" (for stacked layout)
        Collapsible       bool   // Allow collapsing sections in stacked view
    }
    #+END_SRC

** TODO PRIORITY 3: Database Features (using freed SQLite)
   Expand SQLite usage for data that benefits from database features.

*** Search History:
    - Store past search queries with timestamps
    - Quick access to recent/frequent searches
    - Auto-complete from search history
    - Limit history size (configurable)

*** Recent Files/Directories:
    - Track recently accessed paths
    - "Recent" section in sidebar or quick-access menu
    - Configurable history length
    - Clear history option

*** File Tags/Labels:
    - User-defined tags for files/folders
    - Color-coded labels
    - Filter/search by tags
    - Tag management UI

*** Cached Metadata:
    - Thumbnail cache references
    - File preview cache
    - Directory size cache (for large dirs)

** TODO PRIORITY 4: Refactor orchestrator.go into logical sub-files
   Split the monolithic orchestrator.go into separate files within the same package.
   This keeps all code in internal/app without import changes.

*** Files to create:
    - internal/app/clipboard.go - Copy/cut/paste state and operations
    - internal/app/history.go - Navigation history (back/forward stacks)
    - internal/app/navigation.go - Path expansion, validation, navigation logic
    - internal/app/search.go - Search-related handlers and helpers
    - internal/app/file_ops.go - File operations (create, delete, rename, paste)
    - internal/app/conflict.go - Conflict resolution dialog handling

*** Benefits:
    - Easier to navigate and maintain
    - Logical grouping of related functionality
    - Smaller, focused files
    - No import changes needed (same package)

* Planned Features
** TODO Composable UI Architecture
   A flexible, config-driven UI system that allows deep customization of the
   file manager layout and behavior. All components should be modular and
   position-agnostic.

*** Core Principles:
    - Every UI component is optional and configurable
    - Components can be repositioned (left/right, top/bottom)
    - Panel sizes are resizable and persisted
    - Layout presets for quick switching
    - Power users can edit config.json directly

*** Sidebar Composability:
    - [ ] Tabbed vs Stacked layout option
    - [ ] Left or Right positioning
    - [ ] Resizable width (drag handle)
    - [ ] Collapsible (hide/show toggle)
    - [ ] Custom sections (Recent, Tags, Network, etc.)
    - [ ] Section reordering via drag-and-drop
    - [ ] Hide individual sections (Favorites, Drives)

*** Toolbar Composability:
    - [ ] Show/hide toolbar entirely
    - [ ] Top or Bottom positioning
    - [ ] Icon-only vs Icon+Label mode
    - [ ] Customizable button order
    - [ ] Add/remove toolbar buttons
    - [ ] Toolbar presets (minimal, standard, full)

*** File List Composability:
    - [ ] Column visibility toggles (Name, Size, Date, Type)
    - [ ] Column reordering via drag-and-drop
    - [ ] Column width persistence
    - [ ] Row height options (compact, normal, comfortable)
    - [ ] Grid view vs List view vs Details view
    - [ ] Thumbnail size slider (for grid view)

*** Panel System:
    - [ ] Preview panel (right or bottom)
    - [ ] Info/Properties panel
    - [ ] Terminal panel (embedded terminal)
    - [ ] Multiple panels simultaneously
    - [ ] Panel tabs (multiple views in one panel area)
    - [ ] Floating/detachable panels

*** Split View:
    - [ ] Dual-pane mode (Commander style)
    - [ ] Horizontal or Vertical split
    - [ ] Asymmetric split ratios
    - [ ] Sync navigation option
    - [ ] Compare mode for two directories

*** Status Bar Composability:
    - [ ] Show/hide status bar
    - [ ] Configurable info display (file count, selection, path, etc.)
    - [ ] Left/center/right sections
    - [ ] Custom status bar items

*** Layout Presets:
    - [ ] "Minimal" - No sidebar, compact toolbar
    - [ ] "Standard" - Default balanced layout
    - [ ] "Power User" - Dual pane, terminal, all features
    - [ ] "Preview Focus" - Large preview panel
    - [ ] Custom user-defined presets
    - [ ] Quick-switch hotkey (e.g., Ctrl+Shift+1/2/3)

*** Advanced Configuration:
    - [ ] Per-directory layout overrides
    - [ ] Workspace profiles (different configs for different tasks)
    - [ ] Import/export layout configurations
    - [ ] Reset to defaults option

** TODO Favorites Management
*** TODO Favorites Folders (Dropdown Groups)
    Allow organizing favorites into collapsible folder groups.
    - [ ] Create "Favorites Group" data structure
    - [ ] Add UI for creating/managing groups
    - [ ] Collapsible group headers in sidebar
    - [ ] Drag favorites into groups
    - [ ] Persist groups in database

*** TODO Favorites Manager UI
    - [ ] Dedicated favorites management panel/dialog
    - [ ] Reorder favorites via drag-and-drop
    - [ ] Rename favorite display names (alias)
    - [ ] Bulk delete/organize favorites
    - [ ] Import/export favorites

*** TODO Create Favorite from Context Menu
    - [ ] "Create Favorite Here" option in right-click menu
    - [ ] Opens dialog to set favorite name/alias
    - [ ] Option to add to existing group or create new group

** TODO File Preview Panel
   - [ ] Image thumbnails
   - [ ] Text file preview
   - [ ] File metadata display
   - [ ] Toggle preview panel

** TODO Tabs/Multi-window
   - [ ] Tab bar for multiple directories
   - [ ] Ctrl+T new tab
   - [ ] Ctrl+W close tab
   - [ ] Drag tabs to reorder
   - [ ] Click tab to switch between open navigation tabs
   - [ ] Split window view (stretch goal)
   - [ ] Vertical/horizontal split options

*** Implementation Plan - Composable UI Architecture

**** Design Principles
     - All behaviors should be configurable via TabConfig
     - Components should be reusable for future split-view panes
     - Clean separation: TabState (data), TabManager (logic), TabBar (UI)
     - Settings persisted to database, exposed in Settings dialog

**** Phase 1: Configuration & Core Data Structures

***** TabConfig (persisted settings)
      #+BEGIN_SRC go
      type TabConfig struct {
          NewTabLocation    string // "current" | "home" | "custom"
          CustomNewTabPath  string // used when NewTabLocation == "custom"
          LastTabBehavior   string // "close_app" | "keep_empty" | "reopen_home"
          MaxTabs           int    // 0 = unlimited, or specific limit
          EnableTabReorder  bool   // drag to reorder tabs
          RestoreTabsOnStart bool  // persist/restore tabs across sessions
          TabBarPosition    string // "top" | "bottom" (future)
      }
      #+END_SRC

***** TabState (per-tab data)
      #+BEGIN_SRC go
      type TabState struct {
          ID           string   // unique tab identifier
          CurrentPath  string
          Entries      []UIEntry
          SelectedIndex int
          CanBack      bool
          CanForward   bool
          History      []string
          HistoryIndex int
          RawEntries   []UIEntry // for filtering
          DirEntries   []UIEntry // canonical directory contents
          IsSearchResult bool
          SearchQuery  string
          SearchGen    int64    // for stale search handling
      }
      #+END_SRC

***** TabManager (logic layer)
      #+BEGIN_SRC go
      type TabManager struct {
          tabs          []TabState
          activeIndex   int
          config        TabConfig
          // Methods
          NewTab(path string) *TabState
          CloseTab(index int) bool  // returns false if blocked by config
          SwitchTab(index int)
          GetActiveTab() *TabState
          MoveTab(from, to int)     // for reordering
          GetTabCount() int
      }
      #+END_SRC

**** Phase 2: Refactor Orchestrator
     - Extract per-directory state from Orchestrator into TabState
     - Orchestrator holds TabManager instead of single state
     - Global state remains in Orchestrator:
       - window, fs, store, ui (renderer)
       - clipboard, favorites, drives
       - conflict resolution state
       - search engine settings
     - All navigate/search/back/forward operations route through TabManager
     - TabManager notifies Orchestrator of tab changes

**** Phase 3: Tab Bar UI Component
     - New TabBar struct in ui package
     - Renders horizontal scrollable tab list
     - Each tab: folder name, close button (X), active indicator
     - "+" button for new tab
     - Tab click -> ActionSwitchTab
     - Close click -> ActionCloseTab
     - New UIActions: ActionNewTab, ActionCloseTab, ActionSwitchTab, ActionMoveTab

**** Phase 4: Settings UI Integration
     - Add "Tabs" section to Settings dialog
     - Dropdown: New tab opens in (Current directory / Home / Custom path)
     - Dropdown: When closing last tab (Close app / Keep empty tab / Reopen home)
     - Number input: Maximum tabs (0 = unlimited)
     - Checkbox: Enable tab reordering
     - Checkbox: Restore tabs on startup

**** Phase 5: Keyboard Shortcuts
     - Ctrl+T: New tab (respects NewTabLocation config)
     - Ctrl+W: Close tab (respects LastTabBehavior config)
     - Ctrl+Tab: Next tab
     - Ctrl+Shift+Tab: Previous tab
     - Ctrl+1-9: Switch to tab by number

**** Phase 6: Tab Persistence
     - On app close: save tab paths to database (if RestoreTabsOnStart)
     - On app start: restore tabs from database
     - Store as JSON array in settings table

**** Future: Split View Extension
     - Pane struct wraps TabManager + UI region
     - PaneManager holds []Pane and split configuration
     - Each Pane is independent (own tabs, own file list)
     - Split actions: ActionSplitHorizontal, ActionSplitVertical
     - Focus management between panes
     - Drag files between panes for copy/move

*** Detailed Implementation Specification

**** New File: internal/tabs/tabs.go

***** TabConfig Struct
      #+BEGIN_SRC go
      package tabs

      // TabConfig holds user-configurable tab behavior settings
      type TabConfig struct {
          NewTabLocation     string // "current" | "home" | "custom"
          CustomNewTabPath   string // path when NewTabLocation == "custom"
          LastTabBehavior    string // "close_app" | "keep_empty" | "reopen_home"
          MaxTabs            int    // 0 = unlimited
          EnableTabReorder   bool
          RestoreTabsOnStart bool
      }

      // DefaultTabConfig returns sensible defaults
      func DefaultTabConfig() TabConfig {
          return TabConfig{
              NewTabLocation:     "current",
              LastTabBehavior:    "keep_empty",
              MaxTabs:            0,
              EnableTabReorder:   false,
              RestoreTabsOnStart: false,
          }
      }
      #+END_SRC

***** TabState Struct
      #+BEGIN_SRC go
      // TabState holds all per-tab navigation state
      // This is extracted from current Orchestrator fields
      type TabState struct {
          ID            string   // unique identifier (UUID or incremental)
          CurrentPath   string
          History       []string
          HistoryIndex  int
          SelectedIndex int
          CanBack       bool
          CanForward    bool
          IsSearchResult bool
          SearchQuery   string
          SearchGen     int64
      }

      // NewTabState creates a new tab at the given path
      func NewTabState(id, path string) *TabState {
          return &TabState{
              ID:            id,
              CurrentPath:   path,
              History:       []string{path},
              HistoryIndex:  0,
              SelectedIndex: -1,
          }
      }
      #+END_SRC

***** TabManager Struct
      #+BEGIN_SRC go
      // TabManager manages multiple tabs with configurable behavior
      type TabManager struct {
          tabs        []*TabState
          activeIndex int
          config      TabConfig
          nextID      int // for generating unique IDs
      }

      func NewTabManager(config TabConfig, initialPath string) *TabManager {
          tm := &TabManager{
              config: config,
              nextID: 1,
          }
          // Always start with one tab
          tm.tabs = []*TabState{NewTabState("tab-0", initialPath)}
          tm.activeIndex = 0
          return tm
      }

      func (tm *TabManager) GetActiveTab() *TabState {
          if tm.activeIndex >= 0 && tm.activeIndex < len(tm.tabs) {
              return tm.tabs[tm.activeIndex]
          }
          return nil
      }

      func (tm *TabManager) GetTabs() []*TabState {
          return tm.tabs
      }

      func (tm *TabManager) GetActiveIndex() int {
          return tm.activeIndex
      }

      func (tm *TabManager) TabCount() int {
          return len(tm.tabs)
      }

      // NewTab creates a new tab based on config settings
      // Returns the new tab, or nil if max tabs reached
      func (tm *TabManager) NewTab(currentPath, homePath string) *TabState {
          if tm.config.MaxTabs > 0 && len(tm.tabs) >= tm.config.MaxTabs {
              return nil // at limit
          }

          var path string
          switch tm.config.NewTabLocation {
          case "current":
              path = currentPath
          case "home":
              path = homePath
          case "custom":
              path = tm.config.CustomNewTabPath
          default:
              path = currentPath
          }

          id := fmt.Sprintf("tab-%d", tm.nextID)
          tm.nextID++
          tab := NewTabState(id, path)
          tm.tabs = append(tm.tabs, tab)
          tm.activeIndex = len(tm.tabs) - 1
          return tab
      }

      // CloseTab closes the tab at index
      // Returns: shouldCloseApp bool, newActiveTab *TabState
      func (tm *TabManager) CloseTab(index int) (bool, *TabState) {
          if index < 0 || index >= len(tm.tabs) {
              return false, tm.GetActiveTab()
          }

          // Last tab behavior
          if len(tm.tabs) == 1 {
              switch tm.config.LastTabBehavior {
              case "close_app":
                  return true, nil
              case "keep_empty":
                  return false, tm.tabs[0] // don't close, keep current
              case "reopen_home":
                  // Reset the tab to home instead of closing
                  // (caller handles navigation)
                  return false, tm.tabs[0]
              }
          }

          // Remove the tab
          tm.tabs = append(tm.tabs[:index], tm.tabs[index+1:]...)

          // Adjust active index
          if tm.activeIndex >= len(tm.tabs) {
              tm.activeIndex = len(tm.tabs) - 1
          } else if tm.activeIndex > index {
              tm.activeIndex--
          }

          return false, tm.GetActiveTab()
      }

      func (tm *TabManager) SwitchTab(index int) *TabState {
          if index >= 0 && index < len(tm.tabs) {
              tm.activeIndex = index
          }
          return tm.GetActiveTab()
      }

      func (tm *TabManager) NextTab() *TabState {
          next := (tm.activeIndex + 1) % len(tm.tabs)
          return tm.SwitchTab(next)
      }

      func (tm *TabManager) PrevTab() *TabState {
          prev := tm.activeIndex - 1
          if prev < 0 {
              prev = len(tm.tabs) - 1
          }
          return tm.SwitchTab(prev)
      }

      func (tm *TabManager) MoveTab(from, to int) {
          if !tm.config.EnableTabReorder {
              return
          }
          if from < 0 || from >= len(tm.tabs) || to < 0 || to >= len(tm.tabs) {
              return
          }
          tab := tm.tabs[from]
          tm.tabs = append(tm.tabs[:from], tm.tabs[from+1:]...)
          tm.tabs = append(tm.tabs[:to], append([]*TabState{tab}, tm.tabs[to:]...)...)
          // Adjust active index if needed
          if tm.activeIndex == from {
              tm.activeIndex = to
          }
      }

      func (tm *TabManager) UpdateConfig(config TabConfig) {
          tm.config = config
      }
      #+END_SRC

**** New UI Types in internal/ui/renderer.go

***** TabUIItem for rendering
      #+BEGIN_SRC go
      // TabUIItem holds per-tab widget state for rendering
      type TabUIItem struct {
          ID        string
          Label     string           // folder name to display
          Path      string           // full path (for tooltip)
          TabClick  widget.Clickable // click to switch
          CloseClick widget.Clickable // click to close
      }
      #+END_SRC

***** New fields in Renderer struct
      #+BEGIN_SRC go
      // In Renderer struct, add:

      // Tab bar state
      tabBarList    layout.List      // horizontal list for tabs
      tabItems      []TabUIItem      // clickable state per tab
      newTabBtn     widget.Clickable // "+" button
      activeTabIndex int             // which tab is active (for highlighting)
      #+END_SRC

***** Renderer initialization update
      #+BEGIN_SRC go
      // In NewRenderer(), add:
      r.tabBarList.Axis = layout.Horizontal
      #+END_SRC

**** New UIActions in internal/ui/renderer.go

      #+BEGIN_SRC go
      // Add to UIAction const block:
      ActionNewTab
      ActionCloseTab
      ActionSwitchTab
      ActionNextTab
      ActionPrevTab
      #+END_SRC

***** UIEvent updates
      #+BEGIN_SRC go
      // Add to UIEvent struct:
      TabIndex int // for ActionSwitchTab, ActionCloseTab
      #+END_SRC

**** Tab Bar Layout in internal/ui/layout.go

***** layoutTabBar function
      #+BEGIN_SRC go
      func (r *Renderer) layoutTabBar(gtx layout.Context, eventOut *UIEvent) layout.Dimensions {
          return layout.Flex{Axis: layout.Horizontal, Alignment: layout.Middle}.Layout(gtx,
              // Scrollable tab list
              layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
                  return r.tabBarList.Layout(gtx, len(r.tabItems), func(gtx layout.Context, i int) layout.Dimensions {
                      return r.renderTab(gtx, i, eventOut)
                  })
              }),
              // "+" new tab button
              layout.Rigid(func(gtx layout.Context) layout.Dimensions {
                  if r.newTabBtn.Clicked(gtx) {
                      *eventOut = UIEvent{Action: ActionNewTab}
                  }
                  btn := material.Button(r.Theme, &r.newTabBtn, "+")
                  btn.Inset = layout.UniformInset(unit.Dp(4))
                  btn.Background = colLightGray
                  btn.Color = colBlack
                  return btn.Layout(gtx)
              }),
          )
      }
      #+END_SRC

***** renderTab function
      #+BEGIN_SRC go
      func (r *Renderer) renderTab(gtx layout.Context, index int, eventOut *UIEvent) layout.Dimensions {
          tab := &r.tabItems[index]
          isActive := index == r.activeTabIndex

          // Check for tab click BEFORE layout
          if tab.TabClick.Clicked(gtx) {
              *eventOut = UIEvent{Action: ActionSwitchTab, TabIndex: index}
          }

          // Check for close button click
          if tab.CloseClick.Clicked(gtx) {
              *eventOut = UIEvent{Action: ActionCloseTab, TabIndex: index}
          }

          // Tab background color
          bgColor := colLightGray
          if isActive {
              bgColor = colSelected
          }

          return material.Clickable(gtx, &tab.TabClick, func(gtx layout.Context) layout.Dimensions {
              return layout.Background{}.Layout(gtx,
                  func(gtx layout.Context) layout.Dimensions {
                      paint.FillShape(gtx.Ops, bgColor, clip.Rect{Max: gtx.Constraints.Max}.Op())
                      return layout.Dimensions{Size: gtx.Constraints.Max}
                  },
                  func(gtx layout.Context) layout.Dimensions {
                      return layout.Inset{Top: unit.Dp(4), Bottom: unit.Dp(4), Left: unit.Dp(8), Right: unit.Dp(4)}.Layout(gtx,
                          func(gtx layout.Context) layout.Dimensions {
                              return layout.Flex{Axis: layout.Horizontal, Alignment: layout.Middle}.Layout(gtx,
                                  // Tab label
                                  layout.Rigid(func(gtx layout.Context) layout.Dimensions {
                                      lbl := material.Body2(r.Theme, tab.Label)
                                      if isActive {
                                          lbl.Font.Weight = font.Bold
                                      }
                                      lbl.MaxLines = 1
                                      return lbl.Layout(gtx)
                                  }),
                                  layout.Rigid(layout.Spacer{Width: unit.Dp(4)}.Layout),
                                  // Close button
                                  layout.Rigid(func(gtx layout.Context) layout.Dimensions {
                                      return material.Clickable(gtx, &tab.CloseClick, func(gtx layout.Context) layout.Dimensions {
                                          lbl := material.Body2(r.Theme, "Ã—")
                                          lbl.Color = colGray
                                          return lbl.Layout(gtx)
                                      })
                                  }),
                              )
                          })
                  },
              )
          })
      }
      #+END_SRC

***** SetTabs method for Renderer
      #+BEGIN_SRC go
      // SetTabs updates the tab bar with current tabs from TabManager
      func (r *Renderer) SetTabs(tabs []*tabs.TabState, activeIndex int) {
          // Grow or shrink tabItems slice as needed
          for len(r.tabItems) < len(tabs) {
              r.tabItems = append(r.tabItems, TabUIItem{})
          }
          r.tabItems = r.tabItems[:len(tabs)]

          // Update labels and IDs
          for i, t := range tabs {
              r.tabItems[i].ID = t.ID
              r.tabItems[i].Label = filepath.Base(t.CurrentPath)
              r.tabItems[i].Path = t.CurrentPath
          }
          r.activeTabIndex = activeIndex
      }
      #+END_SRC

**** Layout.go Main Layout Changes

***** Insert tab bar into main layout
      #+BEGIN_SRC go
      // In Layout() function, modify the vertical Flex to include tab bar:
      layout.Stacked(func(gtx layout.Context) layout.Dimensions {
          return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
              // File menu button
              layout.Rigid(func(gtx layout.Context) layout.Dimensions {
                  // ... existing file menu code
              }),

              // NEW: Tab bar (insert here, between File menu and nav bar)
              layout.Rigid(func(gtx layout.Context) layout.Dimensions {
                  return layout.Inset{Left: unit.Dp(8), Right: unit.Dp(8)}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
                      return r.layoutTabBar(gtx, &eventOut)
                  })
              }),

              // Nav bar (existing)
              layout.Rigid(func(gtx layout.Context) layout.Dimensions {
                  return layout.Inset{Top: unit.Dp(4), Bottom: unit.Dp(8), Left: unit.Dp(8), Right: unit.Dp(8)}.Layout(gtx,
                      func(gtx layout.Context) layout.Dimensions {
                          return r.layoutNavBar(gtx, state, keyTag, &eventOut)
                      })
              }),

              // ... rest of layout
          )
      }),
      #+END_SRC

**** Keyboard Shortcuts in processGlobalInput

      #+BEGIN_SRC go
      // Add to keyboard handling in processGlobalInput():
      case "T":
          if k.Modifiers.Contain(key.ModCtrl) {
              return UIEvent{Action: ActionNewTab}
          }
      case "W":
          if k.Modifiers.Contain(key.ModCtrl) {
              return UIEvent{Action: ActionCloseTab, TabIndex: -1} // -1 means current
          }
      case "Tab":
          if k.Modifiers.Contain(key.ModCtrl) {
              if k.Modifiers.Contain(key.ModShift) {
                  return UIEvent{Action: ActionPrevTab}
              }
              return UIEvent{Action: ActionNextTab}
          }
      case "1", "2", "3", "4", "5", "6", "7", "8", "9":
          if k.Modifiers.Contain(key.ModCtrl) {
              idx := int(k.Name[0] - '1') // "1" -> 0, "2" -> 1, etc.
              return UIEvent{Action: ActionSwitchTab, TabIndex: idx}
          }
      #+END_SRC

**** Orchestrator Changes in internal/app/orchestrator.go

***** Add TabManager field
      #+BEGIN_SRC go
      import "github.com/justyntemme/razor/internal/tabs"

      type Orchestrator struct {
          // ... existing fields ...
          tabManager *tabs.TabManager  // NEW: replaces history/historyIndex

          // These move to TabState, remove from Orchestrator:
          // history        []string     // REMOVE
          // historyIndex   int          // REMOVE
          // rawEntries     []ui.UIEntry // MOVE to tab-specific storage
          // dirEntries     []ui.UIEntry // MOVE to tab-specific storage
      }
      #+END_SRC

***** Update NewOrchestrator
      #+BEGIN_SRC go
      func NewOrchestrator() *Orchestrator {
          // ... existing code ...

          // Load tab config from settings (or use defaults)
          tabConfig := tabs.DefaultTabConfig()

          o := &Orchestrator{
              // ... existing fields ...
              tabManager: tabs.NewTabManager(tabConfig, home),
          }

          return o
      }
      #+END_SRC

***** Add tab action handlers
      #+BEGIN_SRC go
      // In handleUIEvent():
      case ui.ActionNewTab:
          currentPath := o.tabManager.GetActiveTab().CurrentPath
          newTab := o.tabManager.NewTab(currentPath, o.homePath)
          if newTab != nil {
              o.syncUIWithTabs()
              o.requestDir(newTab.CurrentPath)
          }
      case ui.ActionCloseTab:
          index := evt.TabIndex
          if index == -1 {
              index = o.tabManager.GetActiveIndex()
          }
          shouldClose, activeTab := o.tabManager.CloseTab(index)
          if shouldClose {
              o.window.Perform(system.ActionClose)
              return
          }
          o.syncUIWithTabs()
          if activeTab != nil {
              o.requestDir(activeTab.CurrentPath)
          }
      case ui.ActionSwitchTab:
          tab := o.tabManager.SwitchTab(evt.TabIndex)
          if tab != nil {
              o.syncUIWithTabs()
              o.requestDir(tab.CurrentPath)
          }
      case ui.ActionNextTab:
          tab := o.tabManager.NextTab()
          o.syncUIWithTabs()
          o.requestDir(tab.CurrentPath)
      case ui.ActionPrevTab:
          tab := o.tabManager.PrevTab()
          o.syncUIWithTabs()
          o.requestDir(tab.CurrentPath)
      #+END_SRC

***** Helper to sync UI with tab state
      #+BEGIN_SRC go
      func (o *Orchestrator) syncUIWithTabs() {
          o.ui.SetTabs(o.tabManager.GetTabs(), o.tabManager.GetActiveIndex())
          o.window.Invalidate()
      }
      #+END_SRC

**** Gio Library Calls Summary

| Purpose | Gio Call |
|---------|----------|
| Horizontal tab list | layout.List with Axis: layout.Horizontal |
| Tab click detection | widget.Clickable.Clicked(gtx) |
| Close button click | Nested widget.Clickable inside tab |
| Tab background | paint.FillShape with clip.Rect |
| Active tab highlight | Different bgColor based on isActive |
| Keyboard shortcuts | key.Filter in processGlobalInput |
| App close action | window.Perform(system.ActionClose) |

** TODO Bookmarks Enhancement
   - [ ] Bookmark folders (not just favorites)
   - [ ] Bookmark groups/categories
   - [ ] Quick access sidebar customization

** TODO File Operations
   - [ ] Undo/Redo for file operations
   - [ ] Batch rename
   - [ ] File compression (zip/tar)
   - [ ] File extraction

** DONE Copy/Paste Replace Dialog
   CLOSED: [2024-11-29]
   - [X] Detect file name collisions on paste
   - [X] Mac-style dialog: "Keep Both", "Stop", "Replace"
   - [X] "Apply to All" checkbox for batch operations
   - [X] Skip option
   - [X] Compare dates/sizes in dialog
   - [ ] "Replace if Newer" setting option (FileZilla-style)
   - [ ] Multi-file paste with batch conflict handling

** TODO Network/Remote Access
   - [ ] FTP connection support
   - [ ] SFTP connection support
   - [ ] SMB/CIFS network shares (Windows shares)
   - [ ] NFS mount support
   - [ ] WebDAV support
   - [ ] Save connection profiles
   - [ ] Quick connect dialog
   - [ ] Connection manager sidebar

** TODO View Modes
   - [ ] Grid/icon view
   - [ ] List view (current)
   - [ ] Column view (macOS style)
   - [ ] Thumbnail size options

** TODO Advanced Search
   - [ ] Save search queries
   - [ ] Search history
   - [ ] Regex support
   - [ ] Search in file contents (already partial)

** TODO Keyboard Navigation
   - [ ] Type-to-select (type filename to jump)
   - [ ] Vim-style navigation option
   - [ ] Customizable shortcuts

** TODO Keyboard Shortcuts / Hotkeys
   - [ ] Ctrl+F to focus search bar
   - [ ] Escape to clear search and return focus to file list
   - [ ] Ctrl+L to focus path/address bar
   - [ ] Document all existing shortcuts in Help dialog

** TODO Settings/Preferences
   - [X] Theme selection (light/dark)
   - [ ] Font size options
   - [ ] Default view mode
   - [ ] Startup directory
   - [X] Confirm before delete toggle

* Known Bugs
** TODO Fix dark mode
   - Theme colors not fully applied to all UI elements
   - Need to update hardcoded colors to use theme palette

** TODO Context menu positioning
   - Menu can appear off-screen near edges
   - Allow drawing outside of app container so right-click menus don't reposition unexpectedly
   - Consider using system-level popup windows or Gio's window.Option for overflow

** TODO Large directory performance
   - Directories with 10k+ files can be slow
   - Consider virtualized list

** TODO Dialog text input focus
   - Create New File/Folder dialog doesn't auto-focus the text input
   - User has to click in the textbox before typing
   - Should grab focus automatically when dialog opens

* Technical Debt
** TODO Refactor: Consolidate Path Handling Logic
*** TODO File: razor/internal/app/orchestrator.go (isAbsolutePath)
    - Status: Custom logic for checking absolute paths
    - Action: Leverage standard library function filepath.IsAbs() to simplify the implementation of isAbsolutePath.

** TODO Code Organization
   - [ ] Split large files into smaller modules
   - [ ] Add comprehensive tests
   - [ ] Document public APIs

** TODO Error Handling
   - [ ] User-friendly error messages
   - [ ] Error notification system
   - [ ] Logging improvements

* Development Guidelines

** MUST Use fastwalk over os.ReadDir/filepath.Walk
   The project includes github.com/charlievieth/fastwalk for high-performance
   directory traversal. ALL filesystem walking/reading code MUST use fastwalk
   instead of os.ReadDir(), os.ReadDirEntry(), or filepath.Walk().

   Fastwalk provides:
   - Parallel directory walking with configurable worker pools
   - Efficient symlink handling via StatDirEntry()
   - Built-in depth limiting
   - Better memory efficiency for large directories

   Example usage:
   #+BEGIN_SRC go
   import "github.com/charlievieth/fastwalk"

   // Single directory listing
   conf := &fastwalk.Config{Follow: true}  // Follow symlinks
   fastwalk.Walk(conf, path, func(path string, d fs.DirEntry, err error) error {
       if err != nil {
           return nil  // Skip errors
       }
       // Process entry...
       return nil
   })

   // Use StatDirEntry for file info (follows symlinks properly)
   info, err := fastwalk.StatDirEntry(path, d)
   #+END_SRC

   External search engines (ripgrep, ugrep) are still used when:
   - User has explicitly selected them in settings
   - Query includes contents: directive (content search)

   The builtin fastwalk-based search is the DEFAULT for all operations.

** Debug Logging
   Use the internal/debug package for all debug output:
   #+BEGIN_SRC go
   import "github.com/justyntemme/razor/internal/debug"

   debug.Log(debug.FS, "message: %v", value)      // Filesystem ops
   debug.Log(debug.SEARCH, "query: %q", query)    // Search operations
   debug.Log(debug.APP, "action: %d", action)     // App orchestration
   debug.Log(debug.STORE, "setting: %s", key)     // Database ops
   debug.Log(debug.UI, "event: %v", evt)          // UI operations
   #+END_SRC

   Build with -tags debug to enable logging.
   Use RAZOR_DEBUG=FS,SEARCH to filter categories.

* Notes
- Using Gio UI framework (gioui.org)
- SQLite for favorites/settings persistence
- Cross-platform: Linux, macOS, Windows
- Build with: go build ./cmd/razor
- Debug build: go build -tags debug ./cmd/razor
