#+TITLE: Razor File Manager - Refactor Plan
#+AUTHOR: Refactor Architect
#+DATE: 2024

* User Provided Guidance

** Ideals

*** Event Driven Architecture
- Use a queue system for events to ensure we have non blocking UI thread
- Ensures long running tasks do not block UI threads / redraws
- Utilize Channels for idiomatic golang

*** Idiomatic Go
- Small, focused interfaces
- Composition over inheritance
- Explicit data flow
- No magic or reflection

*** Composable
- Views are pure functions of (data, widgets, handlers)
- Can easily create new views by composing existing ones
- Widget state is separate from render logic

*** Redesign-Friendly
- Change theme once, affects everything
- Swap out view implementations without touching state/actions
- Add new actions without modifying views

** Core Requirements

We should be refactoring this monolithic design with an idiomatic, composable UI
design that uses channels to ensure non blocking UI threads.

We should focus on *performance*, as the entire goal of this project is to create
a *FAST* file explorer that's cross platform.

We want to maintain *readability* for maintainability and rapid development.

** Anti-Patterns to Avoid

We must ensure we do not fall into common LLM pitfalls:
- Adding way too much code for things that can be done efficiently
- Duplicating code instead of creating reusable functions
- Over-engineering simple solutions

** Priority Order

1. *Performance and stability* are king
2. *Maintainability and readability* are a close second
3. Code reduction improves both readability and performance

* Executive Summary

This document outlines a comprehensive refactor plan for the Razor file manager,
transforming it from a monolithic design to an idiomatic, event-driven, composable
architecture using Go channels for non-blocking UI operations.

* Current Architecture Analysis

** Pain Points Identified

1. *Monolithic Orchestrator* (~800 lines)
   - Handles UI events, file ops, search, state, navigation all in one struct
   - Difficult to test individual components
   - Tight coupling between concerns

2. *Mixed UI State and Rendering*
   - Renderer struct holds ~50+ fields mixing widget state with render logic
   - No separation between view logic and state management
   - Hardcoded colors scattered throughout

3. *Blocking Operations*
   - Some file operations can block the main thread
   - Progress updates can flood the channel
   - No rate limiting on UI updates

4. *Code Duplication*
   - Multiple similar menu rendering functions
   - Repeated click handling patterns
   - Similar layout patterns for dialogs

5. *Tight Coupling*
   - Views directly modify state
   - No clear action/event separation
   - Platform code mixed with business logic

* Target Architecture

** Package Structure

#+BEGIN_SRC
internal/
├── event/           # Event bus and action definitions
│   ├── bus.go       # Channel-based event dispatcher
│   ├── actions.go   # Action type definitions
│   └── handlers.go  # Handler registration
│
├── state/           # Centralized state management
│   ├── store.go     # State container with subscriptions
│   ├── state.go     # State struct definitions
│   └── reducers.go  # State update functions
│
├── ui/
│   ├── theme/       # Centralized theming
│   │   ├── theme.go # Theme struct and defaults
│   │   └── colors.go
│   │
│   ├── widget/      # Reusable widget state containers
│   │   ├── list.go
│   │   ├── editor.go
│   │   ├── button.go
│   │   └── dialog.go
│   │
│   ├── view/        # Pure view functions
│   │   ├── navbar.go
│   │   ├── sidebar.go
│   │   ├── filelist.go
│   │   ├── dialogs.go
│   │   └── menus.go
│   │
│   └── app.go       # Main UI coordinator
│
├── fs/              # Filesystem operations (keep mostly as-is)
│   ├── system.go
│   ├── drives_*.go
│   └── worker.go    # NEW: dedicated worker pool
│
├── search/          # Search functionality (keep mostly as-is)
│   ├── engine.go
│   └── query.go
│
├── store/           # Persistence (keep as-is)
│   └── db.go
│
└── platform/        # NEW: Platform abstractions
    ├── open.go      # Interface definition
    ├── open_darwin.go
    ├── open_linux.go
    └── open_windows.go
#+END_SRC

* Phase 1: Event Bus Foundation

** Goal
Create a channel-based event system that decouples UI from business logic.

** Files to Create

*** internal/event/actions.go
#+BEGIN_SRC go
package event

// Action represents a user-initiated or system action
type Action interface {
    Type() string
}

// Define action types as small structs
type (
    Navigate       struct{ Path string }
    Back           struct{}
    Forward        struct{}
    Home           struct{}
    Select         struct{ Index int }
    Search         struct{ Query string }
    ClearSearch    struct{}
    Open           struct{ Path string }
    Copy           struct{ Path string }
    Cut            struct{ Path string }
    Paste          struct{}
    Delete         struct{ Path string }
    CreateFile     struct{ Name string }
    CreateFolder   struct{ Name string }
    Rename         struct{ OldPath, NewPath string }
    ToggleDotfiles struct{ Show bool }
    AddFavorite    struct{ Path string }
    RemoveFavorite struct{ Path string }
    Sort           struct{ Column int; Ascending bool }
    // ... etc
)
#+END_SRC

*** internal/event/bus.go
#+BEGIN_SRC go
package event

// Bus provides non-blocking event dispatch
type Bus struct {
    actions  chan Action
    handlers map[string][]Handler
    done     chan struct{}
}

type Handler func(Action)

func NewBus(bufferSize int) *Bus
func (b *Bus) Dispatch(a Action)      // Non-blocking send
func (b *Bus) Subscribe(actionType string, h Handler)
func (b *Bus) Start()                  // Process loop
func (b *Bus) Stop()
#+END_SRC

** Rationale
- Single channel for all actions prevents scattered event handling
- Buffer prevents UI blocking on slow handlers
- Type-based routing allows focused handlers

* Phase 2: State Management

** Goal
Centralize application state with subscription-based updates.

** Files to Create

*** internal/state/state.go
#+BEGIN_SRC go
package state

import "time"

// AppState holds all application state
type AppState struct {
    // Navigation
    CurrentPath string
    History     []string
    HistoryIdx  int
    CanBack     bool
    CanForward  bool

    // File listing
    Entries       []Entry
    SelectedIndex int
    IsSearching   bool
    SearchQuery   string

    // UI state
    Clipboard    *Clipboard
    Progress     Progress
    Favorites    []string
    Drives       []Drive
    ShowDotfiles bool

    // Dialogs
    DeleteTarget   string
    ConflictState  *Conflict
    CreateDialog   *CreateDialogState

    // Settings
    SortColumn    int
    SortAscending bool
    SearchEngine  string
    DefaultDepth  int
}

// Entry is a minimal file entry
type Entry struct {
    Name    string
    Path    string
    IsDir   bool
    Size    int64
    ModTime time.Time
}
#+END_SRC

*** internal/state/store.go
#+BEGIN_SRC go
package state

import "sync"

// Store manages state with thread-safe updates
type Store struct {
    mu        sync.RWMutex
    state     AppState
    listeners []func(AppState)
}

func NewStore() *Store
func (s *Store) State() AppState          // Read-only copy
func (s *Store) Update(fn func(*AppState)) // Atomic update
func (s *Store) Subscribe(fn func(AppState))
#+END_SRC

** Rationale
- Single source of truth for all state
- Subscription model allows UI to react to changes
- Atomic updates prevent race conditions

* Phase 3: Theme System

** Goal
Centralize all visual styling for easy customization.

** Files to Create

*** internal/ui/theme/theme.go
#+BEGIN_SRC go
package theme

import (
    "image/color"
    "gioui.org/widget/material"
    "gioui.org/unit"
)

type Theme struct {
    *material.Theme
    
    // Colors
    Background    color.NRGBA
    Surface       color.NRGBA
    Primary       color.NRGBA
    Secondary     color.NRGBA
    Error         color.NRGBA
    Success       color.NRGBA
    TextPrimary   color.NRGBA
    TextSecondary color.NRGBA
    TextDisabled  color.NRGBA
    Border        color.NRGBA
    Selected      color.NRGBA
    Directory     color.NRGBA
    
    // Spacing
    SpacingXS unit.Dp
    SpacingS  unit.Dp
    SpacingM  unit.Dp
    SpacingL  unit.Dp
    
    // Sizing
    SidebarWidth unit.Dp
    RowHeight    unit.Dp
    IconSize     unit.Dp
}

func Default() *Theme
func Dark() *Theme
#+END_SRC

** Rationale
- Change appearance in one place
- Enables dark mode support
- Consistent spacing/sizing

* Phase 4: Widget State Separation

** Goal
Separate widget interaction state from render logic.

** Files to Create

*** internal/ui/widget/widgets.go
#+BEGIN_SRC go
package widget

import "gioui.org/widget"

// FileListState holds all clickables for file list
type FileListState struct {
    List       widget.List
    Items      []ItemState
    HeaderBtns [4]widget.Clickable
}

type ItemState struct {
    Click     widget.Clickable
    RightClick int // Tag for right-click detection
}

// NavBarState holds navigation widget state
type NavBarState struct {
    BackBtn    widget.Clickable
    FwdBtn     widget.Clickable
    HomeBtn    widget.Clickable
    PathEditor widget.Editor
    PathClick  widget.Clickable
    Search     SearchState
}

type SearchState struct {
    Editor   widget.Editor
    ClearBtn widget.Clickable
}

// DialogState is reusable for modal dialogs
type DialogState struct {
    Visible   bool
    OKBtn     widget.Clickable
    CancelBtn widget.Clickable
    Editor    widget.Editor
}
#+END_SRC

** Rationale
- Widget state can be reused across views
- Easier to test interaction logic
- Clear ownership of widget instances

* Phase 5: Pure View Functions

** Goal
Views become pure functions: (state, widgets, theme) -> dimensions

** Files to Create

*** internal/ui/view/navbar.go
#+BEGIN_SRC go
package view

import (
    "gioui.org/layout"
    "github.com/justyntemme/razor/internal/state"
    "github.com/justyntemme/razor/internal/ui/theme"
    "github.com/justyntemme/razor/internal/ui/widget"
    "github.com/justyntemme/razor/internal/event"
)

// NavBar renders the navigation bar
// Pure function: no side effects, returns dimensions and optional action
func NavBar(
    gtx layout.Context,
    th *theme.Theme,
    st *state.AppState,
    ws *widget.NavBarState,
) (layout.Dimensions, event.Action) {
    var action event.Action
    
    // Check widget interactions
    if ws.BackBtn.Clicked(gtx) && st.CanBack {
        action = event.Back{}
    }
    // ... render logic
    
    return dims, action
}
#+END_SRC

*** internal/ui/view/filelist.go
#+BEGIN_SRC go
package view

func FileList(
    gtx layout.Context,
    th *theme.Theme,
    entries []state.Entry,
    selected int,
    ws *widget.FileListState,
) (layout.Dimensions, event.Action)

// Internal helper - not exported
func fileRow(
    gtx layout.Context,
    th *theme.Theme,
    entry *state.Entry,
    selected bool,
    ws *widget.ItemState,
) layout.Dimensions
#+END_SRC

*** internal/ui/view/dialogs.go
#+BEGIN_SRC go
package view

// Generic modal dialog renderer
func Modal(
    gtx layout.Context,
    th *theme.Theme,
    title string,
    content layout.Widget,
    actions []ModalAction,
) layout.Dimensions

type ModalAction struct {
    Label   string
    Btn     *widget.Clickable
    Danger  bool
    Primary bool
}

// Specific dialogs compose Modal
func DeleteConfirmDialog(...)
func CreateDialog(...)
func ConflictDialog(...)
#+END_SRC

** Rationale
- Views are testable in isolation
- Easy to compose new views
- Clear data flow

* Phase 6: Main Coordinator Refactor

** Goal
Slim down orchestrator to coordinate between systems.

** Files to Modify

*** internal/ui/app.go (NEW - replaces orchestrator UI parts)
#+BEGIN_SRC go
package ui

type App struct {
    window *app.Window
    theme  *theme.Theme
    
    // Widget states
    navbar   widget.NavBarState
    sidebar  widget.SidebarState
    fileList widget.FileListState
    dialogs  widget.DialogStates
    menus    widget.MenuStates
}

func (a *App) Layout(gtx layout.Context, state *state.AppState) event.Action {
    var action event.Action
    
    // Layout each view, collect any action
    layout.Flex{Axis: layout.Vertical}.Layout(gtx,
        layout.Rigid(func(gtx C) D {
            dims, act := view.NavBar(gtx, a.theme, state, &a.navbar)
            if act != nil { action = act }
            return dims
        }),
        // ... etc
    )
    
    return action
}
#+END_SRC

*** internal/app/app.go (NEW - replaces orchestrator business logic)
#+BEGIN_SRC go
package app

type Application struct {
    bus    *event.Bus
    store  *state.Store
    fs     *fs.System
    db     *store.DB
    ui     *ui.App
    window *app.Window
}

func (a *Application) Run() error {
    // Start event processing
    go a.processEvents()
    
    // Main loop
    for {
        switch e := a.window.Event().(type) {
        case app.FrameEvent:
            gtx := app.NewContext(&ops, e)
            currentState := a.store.State()
            
            // Render UI, get any action
            if action := a.ui.Layout(gtx, &currentState); action != nil {
                a.bus.Dispatch(action)
            }
            
            e.Frame(gtx.Ops)
        }
    }
}

func (a *Application) processEvents() {
    for action := range a.bus.Actions() {
        a.handleAction(action)
    }
}

func (a *Application) handleAction(action event.Action) {
    switch act := action.(type) {
    case event.Navigate:
        a.navigate(act.Path)
    case event.Search:
        a.search(act.Query)
    // ... focused handler methods
    }
}
#+END_SRC

* Phase 7: Performance Optimizations

** Worker Pool for File Operations

*** internal/fs/worker.go
#+BEGIN_SRC go
package fs

type WorkerPool struct {
    workers  int
    jobs     chan Job
    results  chan Result
}

type Job struct {
    ID   int64
    Type JobType
    Path string
    // ...
}

func NewWorkerPool(workers int) *WorkerPool
func (p *WorkerPool) Submit(j Job) int64
func (p *WorkerPool) Results() <-chan Result
#+END_SRC

** UI Update Throttling

#+BEGIN_SRC go
// Throttle progress updates to max 30fps
type Throttler struct {
    interval time.Duration
    last     time.Time
    pending  interface{}
}

func (t *Throttler) Update(v interface{}) bool {
    now := time.Now()
    if now.Sub(t.last) < t.interval {
        t.pending = v
        return false
    }
    t.last = now
    return true
}
#+END_SRC

* Phase 8: Code Consolidation

** Duplicate Code to Eliminate

1. *Menu Rendering* - Create generic menu component
   - layoutFileMenu, layoutContextMenu share 80% code
   - Create: ~view.Menu(items []MenuItem)~

2. *Dialog Rendering* - Already outlined in Phase 5
   - layoutDeleteConfirm, layoutCreateDialog, layoutConflictDialog
   - Create: ~view.Modal~ with composable content

3. *Row Rendering* - Consolidate clickable row patterns
   - renderRow, renderFavoriteRow, renderDriveRow
   - Create: ~view.ListRow~ with variants

4. *Button Styling* - Move to theme
   - Multiple ~material.Button~ configurations
   - Create: ~theme.PrimaryButton~, ~theme.DangerButton~, etc.

** Functions to Extract

#+BEGIN_SRC go
// internal/ui/view/helpers.go

// Separator renders a horizontal divider
func Separator(gtx C, th *theme.Theme) D

// Spacer with theme-aware sizing
func Space(gtx C, size unit.Dp) D

// Icon button with consistent styling
func IconButton(gtx C, th *theme.Theme, btn *widget.Clickable, icon string, enabled bool) D
#+END_SRC

* Implementation Order

** Sprint 1: Foundation (Week 1)
1. Create internal/event package (bus, actions)
2. Create internal/state package (store, state structs)
3. Create internal/ui/theme package
4. Write unit tests for event bus and state store

** Sprint 2: Widget Separation (Week 2)
1. Create internal/ui/widget package
2. Extract widget states from current Renderer
3. Ensure existing functionality still works

** Sprint 3: View Functions (Week 3)
1. Create internal/ui/view package
2. Convert layoutNavBar -> view.NavBar
3. Convert layoutSidebar -> view.Sidebar
4. Convert layoutFileList -> view.FileList
5. Convert dialogs to view.Modal pattern

** Sprint 4: Coordinator Refactor (Week 4)
1. Create internal/ui/app.go (UI coordinator)
2. Create internal/app/app.go (business logic)
3. Split orchestrator into focused handlers
4. Wire everything together

** Sprint 5: Optimization & Cleanup (Week 5)
1. Implement worker pool for file ops
2. Add UI update throttling
3. Consolidate duplicate code
4. Performance testing
5. Documentation

* Testing Strategy

** Unit Tests
- Event bus dispatch/subscribe
- State store updates
- Search query parsing
- Theme color generation

** Integration Tests
- Action -> State change flow
- File operation sequences
- Navigation history

** Manual Testing Checklist
- [ ] Navigate directories
- [ ] Search with all directives
- [ ] Copy/paste files
- [ ] Delete confirmation
- [ ] Conflict resolution
- [ ] Settings persistence
- [ ] All keyboard shortcuts
- [ ] Context menus
- [ ] Cross-platform builds

* Risk Mitigation

** Risk: Breaking Changes During Refactor
*Mitigation*: Keep old code alongside new, switch piece by piece

** Risk: Performance Regression
*Mitigation*: Benchmark critical paths before/after

** Risk: Scope Creep
*Mitigation*: Strict adherence to phases, no new features during refactor

* Success Criteria

1. *No regressions* - All existing functionality works
2. *Faster* - Directory listing renders in <16ms
3. *Smaller* - Reduce total LOC by ~20%
4. *Testable* - >50% unit test coverage on new code
5. *Maintainable* - New developer can add a feature in <1 hour
6. *Themeable* - Dark mode achievable by changing one file

* File Deletion Plan

After successful refactor, remove:
- internal/app/orchestrator.go (split into app.go, handlers/)
- internal/ui/renderer.go (split into widget/, view/)
- internal/ui/layout.go (absorbed into view/)

* Appendix: Interface Definitions

** Key Interfaces

#+BEGIN_SRC go
// Platform abstraction
type Opener interface {
    Open(path string) error
    OpenWith(path, app string) error
}

// Storage abstraction
type Persister interface {
    GetFavorites() ([]string, error)
    AddFavorite(path string) error
    RemoveFavorite(path string) error
    GetSetting(key string) (string, error)
    SetSetting(key, value string) error
}

// Search abstraction
type Searcher interface {
    Search(ctx context.Context, path, query string, opts SearchOpts) (<-chan Entry, error)
    Cancel()
}
#+END_SRC

* Appendix: Channel Buffer Sizes

| Channel | Buffer | Rationale |
|---------+--------+-----------|
| Actions | 100 | Prevent UI blocking on rapid clicks |
| FS Requests | 10 | Limit concurrent file operations |
| FS Responses | 10 | Match request buffer |
| Progress | 50 | Allow burst of updates |
| State Updates | 1 | Single pending update sufficient |
