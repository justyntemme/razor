* StateOwner Architecture

This document describes the StateOwner pattern used in Razor for managing file entry state.

** The Problem: Multiple Copies of Entry Data

Before StateOwner, the codebase had duplicated state that was difficult to keep in sync:

*** Orchestrator Level
- ~rawEntries~ - Raw entries from filesystem (unfiltered)
- ~dirEntries~ - The "canonical" list with tree structure
- ~state.Entries~ - The filtered/displayed list shown to user

*** Per-Tab Level (REMOVED)
- ~tab.DirEntries~ - Cached copy of dirEntries for each tab
- ~tab.RawEntries~ - Cached copy of rawEntries for each tab
- ~tab.ExpandedDirs~ - Map of expanded directory paths

This caused sync bugs where one copy would be updated but others would become stale.

** Solution: StateOwner as Single Source of Truth

~StateOwner~ (defined in ~internal/app/state_owner.go~) is now the single source of truth for all entry state.

*** Key Fields

#+begin_src go
type StateOwner struct {
    mu sync.RWMutex      // Thread-safe access

    entries      []ui.UIEntry      // THE source of truth - what UI displays
    rawEntries   []ui.UIEntry      // Unfiltered entries (for dotfiles toggle)
    currentPath  string
    expandedDirs map[string]bool   // Expanded directories in tree view

    // Display settings
    showDotfiles bool
    sortColumn   ui.SortColumn
    sortAsc      bool

    // Selection state
    selectedIndex   int
    selectedIndices map[int]bool

    window *app.Window  // For invalidation
}
#+end_src

*** Key Methods

| Method                | Purpose                                          |
|-----------------------+--------------------------------------------------|
| GetSnapshot()         | Returns immutable copy for UI rendering          |
| SetEntries()          | Set entries from filesystem (clears expansions)  |
| SetEntriesKeepExpanded()| Set entries but preserve expansion state       |
| ExpandDir(path)       | Expand a directory inline                        |
| CollapseDir(path)     | Collapse an expanded directory                   |
| ToggleDotfiles(show)  | Toggle dotfile visibility                        |
| SetSort(col, asc)     | Change sort settings                             |
| RemoveEntry(path)     | Remove entry without resetting expansions        |
| RemoveEntries(paths)  | Remove multiple entries                          |
| RefreshExpandedDir()  | Refresh children of an expanded directory        |

** Data Flow

#+begin_src
Filesystem Read ──> StateOwner.SetEntries()
                         │
                         ▼
              StateOwner (internal filtering/sorting)
                         │
                         ▼
              GetSnapshot() ──> UI State for rendering
#+end_src

** Guidelines for Future Development

*** DO:
1. Always use StateOwner methods to modify entry data
2. Call GetSnapshot() to get entries for UI rendering
3. Sync snapshot to ~o.state.Entries~ after StateOwner operations
4. Use RemoveEntry/RemoveEntries for deletions to preserve expansions

*** DON'T:
1. Store entry copies in tabs or other locations
2. Directly modify ~o.state.Entries~ without going through StateOwner
3. Create new entry caches outside StateOwner
4. Call refreshCurrentDir() when you can use RemoveEntry() instead

*** Example: Correct Pattern for File Operations

#+begin_src go
// Delete a file while preserving expanded state
func (o *Orchestrator) doDelete(path string) {
    err := deleteItem(path)
    if err != nil {
        return
    }

    // Use StateOwner to remove (preserves expansion state)
    o.stateOwner.RemoveEntry(path)

    // Sync to state for UI
    snapshot := o.stateOwner.GetSnapshot()
    o.stateMu.Lock()
    o.state.Entries = snapshot.Entries
    o.stateMu.Unlock()

    o.window.Invalidate()
}
#+end_src

** Tab Switching

Tabs no longer cache entry data. They only store metadata:

#+begin_src go
type TabState struct {
    ID           string
    CurrentPath  string
    History      []string
    HistoryIndex int
    SelectedIdx  int
    ExpandedDirs map[string]bool  // Which dirs were expanded
}
#+end_src

When switching tabs:
1. Save current expansion state to the outgoing tab
2. Clear StateOwner expansions
3. Restore expansion map from incoming tab (to UI renderer)
4. Request directory from filesystem (re-fetches fresh data)
5. StateOwner applies expansions during rebuild

** Thread Safety

StateOwner uses ~sync.RWMutex~:
- Read operations use ~RLock()~ - allows concurrent reads
- Write operations use ~Lock()~ - exclusive access

The pattern is optimized for the file manager use case where:
- Reads are frequent (UI rendering)
- Writes are infrequent (user actions)
- Contention is low

** Testing

Manual testing checklist:
1. Expand/collapse directories - state preserved correctly
2. Toggle dotfiles with expanded dirs - both levels update
3. Switch tabs - expansion state saved/restored
4. Delete in expanded view - only deleted item removed
5. fsnotify updates - all tabs viewing directory get updated
