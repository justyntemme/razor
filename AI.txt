# Git Repository Content Extraction
# Generated on Fri Nov 28 21:13:14 CST 2025
# Repository: git@github.com:justyntemme/razor
############################################################
# File: cmd/razor/console_unix.go
############################################################

//go:build !windows

package main

func manageConsole(debug bool) {
	// No-op on non-Windows systems
}

############################################################
# File: cmd/razor/console_windows.go
############################################################

//go:build windows

package main

import (
	"syscall"
)

// manageConsole handles the console window visibility on Windows.
// If debug is false, it detaches (hides) the console window.
func manageConsole(debug bool) {
	if !debug {
		// FreeConsole detaches the calling process from its console.
		// If the app was launched via 'go run', the console window remains but 
		// the app stops writing to it.
		// If built and launched from Explorer, this prevents a persistent console window.
		kernel32 := syscall.NewLazyDLL("kernel32.dll")
		freeConsole := kernel32.NewProc("FreeConsole")
		freeConsole.Call()
	}
}

############################################################
# File: cmd/razor/main.go
############################################################

package main

import (
	"flag"
	"github.com/justyntemme/razor/internal/app"
)

func main() {
	debug := flag.Bool("debug", false, "Enable verbose debug logging")
	startPath := flag.String("path", "", "Initial directory path (defaults to user home)")
	flag.Parse()

	// Handle OS-specific console visibility
	manageConsole(*debug)

	// Pass flags to the application core
	app.Main(*debug, *startPath)
}

############################################################
# File: go.mod
############################################################

module github.com/justyntemme/razor

go 1.25.4

require (
	gioui.org v0.9.0
	github.com/charlievieth/fastwalk v1.0.14
	github.com/justyntemme/fast-text-search v0.0.1
)

require (
	gioui.org/shader v1.0.8 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/go-text/typesetting v0.3.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/ncruces/go-strftime v0.1.9 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	golang.org/x/exp v0.0.0-20250620022241-b7579e27df2b // indirect
	golang.org/x/exp/shiny v0.0.0-20250408133849-7e4ce0ab07d0 // indirect
	golang.org/x/image v0.26.0 // indirect
	golang.org/x/sys v0.36.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	modernc.org/libc v1.66.10 // indirect
	modernc.org/mathutil v1.7.1 // indirect
	modernc.org/memory v1.11.0 // indirect
	modernc.org/sqlite v1.40.1 // indirect
)


############################################################
# File: go.sum
############################################################

eliasnaur.com/font v0.0.0-20230308162249-dd43949cb42d h1:ARo7NCVvN2NdhLlJE9xAbKweuI9L6UgfTbYb0YwPacY=
eliasnaur.com/font v0.0.0-20230308162249-dd43949cb42d/go.mod h1:OYVuxibdk9OSLX8vAqydtRPP87PyTFcT9uH3MlEGBQA=
gioui.org v0.9.0 h1:4u7XZwnb5kzQW91Nz/vR0wKD6LdW9CaVF96r3rfy4kc=
gioui.org v0.9.0/go.mod h1:CjNig0wAhLt9WZxOPAusgFD8x8IRvqt26LdDBa3Jvao=
gioui.org/cpu v0.0.0-20210808092351-bfe733dd3334/go.mod h1:A8M0Cn5o+vY5LTMlnRoK3O5kG+rH0kWfJjeKd9QpBmQ=
gioui.org/shader v1.0.8 h1:6ks0o/A+b0ne7RzEqRZK5f4Gboz2CfG+mVliciy6+qA=
gioui.org/shader v1.0.8/go.mod h1:mWdiME581d/kV7/iEhLmUgUK5iZ09XR5XpduXzbePVM=
github.com/charlievieth/fastwalk v1.0.14 h1:3Eh5uaFGwHZd8EGwTjJnSpBkfwfsak9h6ICgnWlhAyg=
github.com/charlievieth/fastwalk v1.0.14/go.mod h1:diVcUreiU1aQ4/Wu3NbxxH4/KYdKpLDojrQ1Bb2KgNY=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/go-text/typesetting v0.3.0 h1:OWCgYpp8njoxSRpwrdd1bQOxdjOXDj9Rqart9ML4iF4=
github.com/go-text/typesetting v0.3.0/go.mod h1:qjZLkhRgOEYMhU9eHBr3AR4sfnGJvOXNLt8yRAySFuY=
github.com/go-text/typesetting-utils v0.0.0-20241103174707-87a29e9e6066 h1:qCuYC+94v2xrb1PoS4NIDe7DGYtLnU2wWiQe9a1B1c0=
github.com/go-text/typesetting-utils v0.0.0-20241103174707-87a29e9e6066/go.mod h1:DDxDdQEnB70R8owOx3LVpEFvpMK9eeH1o2r0yZhFI9o=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/justyntemme/fast-text-search v0.0.1 h1:XPpGSTnFtbMFpNsLcmBwRP0s8qbFGvYTSPEa5D6wW8Q=
github.com/justyntemme/fast-text-search v0.0.1/go.mod h1:yfe24XBoDRbVAMIWvbJTYz37C6horurVUFQadPP5ybM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/ncruces/go-strftime v0.1.9 h1:bY0MQC28UADQmHmaF5dgpLmImcShSi2kHU9XLdhx/f4=
github.com/ncruces/go-strftime v0.1.9/go.mod h1:Fwc5htZGVVkseilnfgOVb9mKy6w1naJmn9CehxcKcls=
github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec h1:W09IVJc94icq4NjY3clb7Lk8O1qJ8BdBEF8z0ibU0rE=
github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec/go.mod h1:qqbHyh8v60DhA7CoWK5oRCqLrMHRGoxYCSS9EjAz6Eo=
golang.org/x/exp v0.0.0-20250408133849-7e4ce0ab07d0 h1:R84qjqJb5nVJMxqWYb3np9L5ZsaDtB+a39EqjV0JSUM=
golang.org/x/exp v0.0.0-20250408133849-7e4ce0ab07d0/go.mod h1:S9Xr4PYopiDyqSyp5NjCrhFrqg6A5zA2E/iPHPhqnS8=
golang.org/x/exp v0.0.0-20250620022241-b7579e27df2b h1:M2rDM6z3Fhozi9O7NWsxAkg/yqS/lQJ6PmkyIV3YP+o=
golang.org/x/exp v0.0.0-20250620022241-b7579e27df2b/go.mod h1:3//PLf8L/X+8b4vuAfHzxeRUl04Adcb341+IGKfnqS8=
golang.org/x/exp/shiny v0.0.0-20250408133849-7e4ce0ab07d0 h1:tMSqXTK+AQdW3LpCbfatHSRPHeW6+2WuxaVQuHftn80=
golang.org/x/exp/shiny v0.0.0-20250408133849-7e4ce0ab07d0/go.mod h1:ygj7T6vSGhhm/9yTpOQQNvuAUFziTH7RUiH74EoE2C8=
golang.org/x/image v0.26.0 h1:4XjIFEZWQmCZi6Wv8BoxsDhRU3RVnLX04dToTDAEPlY=
golang.org/x/image v0.26.0/go.mod h1:lcxbMFAovzpnJxzXS3nyL83K27tmqtKzIJpctK8YO5c=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.33.0 h1:q3i8TbbEz+JRD9ywIRlyRAQbM0qF7hu24q3teo2hbuw=
golang.org/x/sys v0.33.0/go.mod h1:BJP2sWEmIv4KK5OTEluFJCKSidICx8ciO85XgH3Ak8k=
golang.org/x/sys v0.36.0 h1:KVRy2GtZBrk1cBYA7MKu5bEZFxQk4NIDV6RLVcC8o0k=
golang.org/x/sys v0.36.0/go.mod h1:OgkHotnGiDImocRcuBABYBEXf8A9a87e/uXjp9XT3ks=
golang.org/x/text v0.24.0 h1:dd5Bzh4yt5KYA8f9CJHCP4FB4D51c2c6JvN37xJJkJ0=
golang.org/x/text v0.24.0/go.mod h1:L8rBsPeo2pSS+xqN0d5u2ikmjtmoJbDBT1b7nHvFCdU=
modernc.org/libc v1.66.10 h1:yZkb3YeLx4oynyR+iUsXsybsX4Ubx7MQlSYEw4yj59A=
modernc.org/libc v1.66.10/go.mod h1:8vGSEwvoUoltr4dlywvHqjtAqHBaw0j1jI7iFBTAr2I=
modernc.org/mathutil v1.7.1 h1:GCZVGXdaN8gTqB1Mf/usp1Y/hSqgI2vAGGP4jZMCxOU=
modernc.org/mathutil v1.7.1/go.mod h1:4p5IwJITfppl0G4sUEDtCr4DthTaT47/N3aT6MhfgJg=
modernc.org/memory v1.11.0 h1:o4QC8aMQzmcwCK3t3Ux/ZHmwFPzE6hf2Y5LbkRs+hbI=
modernc.org/memory v1.11.0/go.mod h1:/JP4VbVC+K5sU2wZi9bHoq2MAkCnrt2r98UGeSK7Mjw=
modernc.org/sqlite v1.40.1 h1:VfuXcxcUWWKRBuP8+BR9L7VnmusMgBNNnBYGEe9w/iY=
modernc.org/sqlite v1.40.1/go.mod h1:9fjQZ0mB1LLP0GYrp39oOJXx/I2sxEnZtzCmEQIKvGE=


############################################################
# File: go.work
############################################################

go 1.25.4

use (
	.
)


############################################################
# File: internal/app/orchestrator.go
############################################################

package app

import (
	"log"
	"os"
	"path/filepath"

	"gioui.org/app"
	"gioui.org/op"

	"github.com/justyntemme/razor/internal/fs"
	"github.com/justyntemme/razor/internal/store"
	"github.com/justyntemme/razor/internal/ui"
)

type Orchestrator struct {
	window *app.Window
	fs     *fs.System
	store  *store.DB
	ui     *ui.Renderer
	state  ui.State

	history      []string
	historyIndex int
	debug        bool
}

func NewOrchestrator(debug bool) *Orchestrator {
	renderer := ui.NewRenderer()
	renderer.Debug = debug

	return &Orchestrator{
		window:       new(app.Window),
		fs:           fs.NewSystem(),
		store:        store.NewDB(),
		ui:           renderer,
		state:        ui.State{CurrentPath: "Initializing...", SelectedIndex: -1, Favorites: make(map[string]bool)},
		history:      make([]string, 0),
		historyIndex: -1,
		debug:        debug,
	}
}

// Run now accepts startPath to handle the --path flag or default to Home
func (o *Orchestrator) Run(startPath string) error {
	if o.debug {
		log.Println("Starting Razor in DEBUG mode")
	}

	// 1. Initialize DB
	configDir, _ := os.UserConfigDir()
	dbPath := filepath.Join(configDir, "razor", "razor.db")
	if err := o.store.Open(dbPath); err != nil {
		log.Printf("Failed to open DB: %v", err)
	}
	defer o.store.Close()

	// 2. Start Workers
	go o.fs.Start()
	go o.store.Start()
	
	// 3. Start Event Listener
	go o.processEvents()

	// 4. Initial Data Fetch
	o.store.RequestChan <- store.Request{Op: store.FetchFavorites}

	// 5. Initial Navigation
	initialPath := startPath
	if initialPath == "" {
		home, err := os.UserHomeDir()
		if err == nil {
			initialPath = home
		} else {
			initialPath, _ = os.Getwd()
		}
	}
	o.navigate(initialPath)

	var ops op.Ops
	for {
		switch e := o.window.Event().(type) {
		case app.DestroyEvent:
			return e.Err
		case app.FrameEvent:
			gtx := app.NewContext(&ops, e)
			
			evt := o.ui.Layout(gtx, &o.state)
			
			if o.debug && evt.Action != ui.ActionNone {
				log.Printf("[DEBUG] UI Action: %d, Path: %s, Index: %d", evt.Action, evt.Path, evt.NewIndex)
			}

			switch evt.Action {
			case ui.ActionNavigate:
				o.navigate(evt.Path)
			case ui.ActionBack:
				o.goBack()
			case ui.ActionForward:
				o.goForward()
			case ui.ActionSelect:
				o.state.SelectedIndex = evt.NewIndex
				o.window.Invalidate()
			case ui.ActionSearch:
				o.search(evt.Path)
			case ui.ActionOpen:
				o.openFile(evt.Path)
			case ui.ActionAddFavorite:
				o.store.RequestChan <- store.Request{Op: store.AddFavorite, Path: evt.Path}
			case ui.ActionRemoveFavorite:
				o.store.RequestChan <- store.Request{Op: store.RemoveFavorite, Path: evt.Path}
			}

			e.Frame(gtx.Ops)
		}
	}
}

func (o *Orchestrator) navigate(path string) {
	if o.debug {
		log.Printf("[DEBUG] Navigate requested: %s", path)
	}
	if o.historyIndex >= 0 && o.historyIndex < len(o.history)-1 {
		o.history = o.history[:o.historyIndex+1]
	}
	o.history = append(o.history, path)
	o.historyIndex = len(o.history) - 1
	o.requestDir(path)
}

func (o *Orchestrator) goBack() {
	current := o.state.CurrentPath
	parent := filepath.Dir(current)
	if parent == current {
		return
	}
	if o.historyIndex > 0 && o.history[o.historyIndex-1] == parent {
		o.historyIndex--
		o.requestDir(parent)
		return
	}
	o.history = append(o.history[:o.historyIndex], append([]string{parent}, o.history[o.historyIndex:]...)...)
	o.requestDir(parent)
}

func (o *Orchestrator) goForward() {
	if o.historyIndex < len(o.history)-1 {
		o.historyIndex++
		path := o.history[o.historyIndex]
		o.requestDir(path)
	}
}

func (o *Orchestrator) requestDir(path string) {
	o.state.SelectedIndex = -1
	o.fs.RequestChan <- fs.Request{Op: fs.FetchDir, Path: path}
}

func (o *Orchestrator) search(query string) {
	if query == "" {
		if o.debug {
			log.Printf("[DEBUG] Search cleared, reverting to standard view.")
		}
		o.requestDir(o.state.CurrentPath)
		return
	}

	if o.debug {
		log.Printf("[DEBUG] Searching for: %s in %s", query, o.state.CurrentPath)
	}
	o.state.SelectedIndex = -1
	o.fs.RequestChan <- fs.Request{
		Op:    fs.SearchDir,
		Path:  o.state.CurrentPath,
		Query: query,
	}
}

func (o *Orchestrator) openFile(path string) {
    if o.debug {
        log.Printf("[DEBUG] Opening file via platform handler: %s", path)
    }

	// Delegate to the OS-specific implementation in platform_*.go
	if err := platformOpen(path); err != nil {
		log.Printf("Error opening file: %v", err)
	}
}

func (o *Orchestrator) processEvents() {
	for {
		select {
		case resp := <-o.fs.ResponseChan:
			o.handleFSResponse(resp)
		case resp := <-o.store.ResponseChan:
			o.handleStoreResponse(resp)
		}
	}
}

func (o *Orchestrator) handleFSResponse(resp fs.Response) {
	if resp.Err != nil {
		log.Printf("FS Error: %v", resp.Err)
		return
	}

	if o.debug {
		log.Printf("[DEBUG] Loaded %d entries for %s", len(resp.Entries), resp.Path)
	}

	uiEntries := make([]ui.UIEntry, len(resp.Entries))
	for i, e := range resp.Entries {
		uiEntries[i] = ui.UIEntry{
			Name:    e.Name,
			Path:    e.Path,
			IsDir:   e.IsDir,
			Size:    e.Size,
			ModTime: e.ModTime,
		}
	}

	o.state.CurrentPath = resp.Path
	o.state.Entries = uiEntries
	
	parent := filepath.Dir(resp.Path)
	o.state.CanBack = parent != resp.Path
	o.state.CanForward = o.historyIndex < len(o.history)-1

	if o.state.SelectedIndex >= len(uiEntries) {
		o.state.SelectedIndex = -1
	}

	o.window.Invalidate()
}

func (o *Orchestrator) handleStoreResponse(resp store.Response) {
	if resp.Err != nil {
		log.Printf("Store Error: %v", resp.Err)
		return
	}

	if resp.Op == store.FetchFavorites {
		favMap := make(map[string]bool)
		favList := make([]ui.FavoriteItem, len(resp.Favorites))
		
		for i, path := range resp.Favorites {
			favMap[path] = true
			favList[i] = ui.FavoriteItem{
				Path: path,
				Name: filepath.Base(path),
			}
		}
		
		o.state.Favorites = favMap
		o.state.FavList = favList
		o.window.Invalidate()
	}
}

// Main now correctly matches the signature expected by cmd/razor
func Main(debug bool, startPath string) {
	go func() {
		orchestrator := NewOrchestrator(debug)
		if err := orchestrator.Run(startPath); err != nil {
			log.Fatal(err)
		}
		os.Exit(0)
	}()
	app.Main()
}

############################################################
# File: internal/app/platform_darwin.go
############################################################

//go:build darwin

package app

import "os/exec"

// platformOpen opens the file using the macOS 'open' command.
func platformOpen(path string) error {
	return exec.Command("open", path).Start()
}


############################################################
# File: internal/app/platform_linux.go
############################################################

//go:build linux

package app

import "os/exec"

// platformOpen opens the file using 'xdg-open'.
func platformOpen(path string) error {
	return exec.Command("xdg-open", path).Start()
}


############################################################
# File: internal/app/platform_windows.go
############################################################

//go:build windows

package app

import "os/exec"

// platformOpen opens the file using the Windows 'start' command.
func platformOpen(path string) error {
	// 'cmd /c start "" "path"' is the standard way to launch files in Windows
	return exec.Command("cmd", "/c", "start", "", path).Start()
}


############################################################
# File: internal/fs/system.go
############################################################

package fs

import (
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/charlievieth/fastwalk"
	"github.com/justyntemme/fast-text-search/fts"
)

type EventType int

const (
	FetchDir EventType = iota
	SearchDir
)

type Request struct {
	Op    EventType
	Path  string
	Query string // Search term
}

type Entry struct {
	Name    string
	Path    string
	IsDir   bool
	Size    int64
	ModTime time.Time
}

type Response struct {
	Op      EventType
	Path    string
	Entries []Entry
	Err     error
}

type System struct {
	RequestChan  chan Request
	ResponseChan chan Response
}

func NewSystem() *System {
	return &System{
		RequestChan:  make(chan Request, 10),
		ResponseChan: make(chan Response, 10),
	}
}

func (s *System) Start() {
	for req := range s.RequestChan {
		switch req.Op {
		case FetchDir:
			s.handleFetchDir(req)
		case SearchDir:
			s.handleSearchDir(req)
		}
	}
}

func (s *System) handleFetchDir(req Request) {
	absPath, err := filepath.Abs(req.Path)
	if err != nil {
		s.ResponseChan <- Response{Op: req.Op, Err: err}
		return
	}

	var mu sync.Mutex
	entries := make([]Entry, 0, 100)

	config := fastwalk.Config{
		Follow: false,
	}

	err = fastwalk.Walk(&config, absPath, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return nil
		}
		if path == absPath {
			return nil
		}

		info, _ := d.Info()
		size := int64(0)
		var modTime time.Time

		if info != nil {
			size = info.Size()
			modTime = info.ModTime()
		}

		entry := Entry{
			Name:    d.Name(),
			Path:    path,
			IsDir:   d.IsDir(),
			Size:    size,
			ModTime: modTime,
		}

		mu.Lock()
		entries = append(entries, entry)
		mu.Unlock()

		if d.IsDir() {
			return filepath.SkipDir
		}

		return nil
	})

	if err != nil && err != filepath.SkipDir {
		s.ResponseChan <- Response{Op: req.Op, Err: err}
		return
	}

	sort.Slice(entries, func(i, j int) bool {
		if entries[i].IsDir != entries[j].IsDir {
			return entries[i].IsDir
		}
		return entries[i].Name < entries[j].Name
	})

	s.ResponseChan <- Response{
		Op:      req.Op,
		Path:    absPath,
		Entries: entries,
	}
}

func (s *System) handleSearchDir(req Request) {
	absPath, err := filepath.Abs(req.Path)
	if err != nil {
		s.ResponseChan <- Response{Op: req.Op, Err: err}
		return
	}

	// Use a map to track unique entries by path (prevents duplicates)
	uniqueEntries := make(map[string]Entry)
	var mu sync.Mutex

	// 1. Content Search (fast-text-search)
	// FTS(searchString, directory, ignoreExt, ignoreFolders, fileName, extType)
	// We pass empty slices for ignores to search everything.
	contentResults := fts.FTS(req.Query, absPath, []string{}, []string{}, "", "")

	for _, res := range contentResults {
		// res is the path string itself
		info, err := os.Stat(res)
		if err != nil {
			continue
		}

		uniqueEntries[res] = Entry{
			Name:    info.Name(),
			Path:    res,
			IsDir:   info.IsDir(),
			Size:    info.Size(),
			ModTime: info.ModTime(),
		}
	}

	// 2. Filename Search (fastwalk)
	config := fastwalk.Config{
		Follow: false,
	}

	queryLower := strings.ToLower(req.Query)

	_ = fastwalk.Walk(&config, absPath, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return nil
		}
		if path == absPath {
			return nil
		}

		// Check if filename matches query (case-insensitive substring)
		if strings.Contains(strings.ToLower(d.Name()), queryLower) {
			mu.Lock()
			defer mu.Unlock()

			// Only add if not already found by content search
			if _, exists := uniqueEntries[path]; !exists {
				info, _ := d.Info()
				size := int64(0)
				var modTime time.Time
				if info != nil {
					size = info.Size()
					modTime = info.ModTime()
				}

				uniqueEntries[path] = Entry{
					Name:    d.Name(),
					Path:    path,
					IsDir:   d.IsDir(),
					Size:    size,
					ModTime: modTime,
				}
			}
		}
		return nil
	})

	// Convert map back to slice
	entries := make([]Entry, 0, len(uniqueEntries))
	for _, entry := range uniqueEntries {
		entries = append(entries, entry)
	}

	// Sort results
	sort.Slice(entries, func(i, j int) bool {
		if entries[i].IsDir != entries[j].IsDir {
			return entries[i].IsDir
		}
		return entries[i].Name < entries[j].Name
	})

	// Send back results
	s.ResponseChan <- Response{
		Op:      req.Op,
		Path:    req.Path, // Keep context of where we searched
		Entries: entries,
	}
}

############################################################
# File: internal/store/db.go
############################################################

package store

import (
	"database/sql"
	"log"
	"os"
	"path/filepath"

	_ "modernc.org/sqlite" // Pure Go SQLite driver
)

type EventType int

const (
	FetchFavorites EventType = iota
	AddFavorite
	RemoveFavorite
)

type Request struct {
	Op   EventType
	Path string
}

type Response struct {
	Op        EventType
	Favorites []string // List of paths
	Err       error
}

type DB struct {
	conn         *sql.DB
	RequestChan  chan Request
	ResponseChan chan Response
}

func NewDB() *DB {
	return &DB{
		RequestChan:  make(chan Request, 10),
		ResponseChan: make(chan Response, 10),
	}
}

// Open initializes the database connection and schema
func (d *DB) Open(dbPath string) error {
	// Ensure directory exists
	dir := filepath.Dir(dbPath)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return err
	}

	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		return err
	}

	// Performance Tuning
	// WAL mode allows simultaneous readers and writers
	if _, err := db.Exec("PRAGMA journal_mode=WAL;"); err != nil {
		return err
	}
	// Synchronous NORMAL is safe against app crashes, faster than FULL
	if _, err := db.Exec("PRAGMA synchronous=NORMAL;"); err != nil {
		return err
	}

	// Schema
	query := `
	CREATE TABLE IF NOT EXISTS favorites (
		path TEXT PRIMARY KEY,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);
	`
	if _, err := db.Exec(query); err != nil {
		return err
	}

	d.conn = db
	return nil
}

func (d *DB) Start() {
	for req := range d.RequestChan {
		switch req.Op {
		case FetchFavorites:
			d.handleFetch()
		case AddFavorite:
			d.handleAdd(req.Path)
		case RemoveFavorite:
			d.handleRemove(req.Path)
		}
	}
}

func (d *DB) handleFetch() {
	rows, err := d.conn.Query("SELECT path FROM favorites ORDER BY created_at ASC")
	if err != nil {
		d.ResponseChan <- Response{Op: FetchFavorites, Err: err}
		return
	}
	defer rows.Close()

	var favs []string
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err == nil {
			favs = append(favs, path)
		}
	}

	d.ResponseChan <- Response{Op: FetchFavorites, Favorites: favs}
}

func (d *DB) handleAdd(path string) {
	// Use INSERT OR IGNORE to handle duplicates gracefully
	_, err := d.conn.Exec("INSERT OR IGNORE INTO favorites (path) VALUES (?)", path)
	if err != nil {
		log.Printf("Store Error: %v", err)
	}
	// Always trigger a fetch after modification to sync UI
	d.handleFetch()
}

func (d *DB) handleRemove(path string) {
	_, err := d.conn.Exec("DELETE FROM favorites WHERE path = ?", path)
	if err != nil {
		log.Printf("Store Error: %v", err)
	}
	d.handleFetch()
}

func (d *DB) Close() {
	if d.conn != nil {
		d.conn.Close()
	}
}


############################################################
# File: internal/ui/components.go
############################################################

package ui

import (
	"fmt"
	"image/color"

	"gioui.org/io/event"
	"gioui.org/io/pointer"
	"gioui.org/layout"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/unit"
	"gioui.org/widget"
	"gioui.org/widget/material"
)

// renderMenuItem creates a standard clickable menu row (used in Context Menu, File Menu)
func (r *Renderer) renderMenuItem(gtx layout.Context, clk *widget.Clickable, text string) layout.Dimensions {
	return material.Clickable(gtx, clk, func(gtx layout.Context) layout.Dimensions {
		return layout.UniformInset(unit.Dp(10)).Layout(gtx, func(gtx layout.Context) layout.Dimensions {
			txt := material.Body2(r.Theme, text)
			txt.Color = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
			return txt.Layout(gtx)
		})
	})
}

// renderFavoriteRow creates a favorite item row with proper left/right click detection.
// This is structured EXACTLY like renderRow in renderer.go:
//   - layout.Stack with two children
//   - layout.Stacked: material.Clickable wrapping the visual content
//   - layout.Expanded: right-click detection area with clip.Rect, event.Op, pointer.PassOp
func (r *Renderer) renderFavoriteRow(gtx layout.Context, fav *FavoriteItem, selected bool) layout.Dimensions {
	return layout.Stack{}.Layout(gtx,
		// First child: Stacked - clickable content (exactly like renderRow)
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			return material.Clickable(gtx, &fav.Clickable, func(gtx layout.Context) layout.Dimensions {
				return layout.Stack{}.Layout(gtx,
					// Selection highlight background
					layout.Expanded(func(gtx layout.Context) layout.Dimensions {
						if selected {
							paint.FillShape(gtx.Ops, color.NRGBA{R: 200, G: 220, B: 255, A: 255}, clip.Rect{Max: gtx.Constraints.Min}.Op())
						}
						return layout.Dimensions{}
					}),
					// Text content - use Flex with Flexed(1) to fill width (like renderRow does)
					layout.Stacked(func(gtx layout.Context) layout.Dimensions {
						return layout.Inset{
							Top: unit.Dp(8), Bottom: unit.Dp(8), Left: unit.Dp(12), Right: unit.Dp(12),
						}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
							// Use Flex to ensure the row fills the full available width
							// This matches renderRow which uses Flex with Flexed children
							return layout.Flex{Axis: layout.Horizontal}.Layout(gtx,
								layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
									txt := material.Body1(r.Theme, fav.Name)
									txt.Color = color.NRGBA{R: 0, G: 0, B: 128, A: 255}
									txt.MaxLines = 1
									return txt.Layout(gtx)
								}),
							)
						})
					}),
				)
			})
		}),

		// Second child: Expanded - right-click detection area (exactly like renderRow)
		layout.Expanded(func(gtx layout.Context) layout.Dimensions {
			defer clip.Rect{Max: gtx.Constraints.Min}.Push(gtx.Ops).Pop()
			event.Op(gtx.Ops, &fav.RightClickTag)
			defer pointer.PassOp{}.Push(gtx.Ops).Pop()
			return layout.Dimensions{Size: gtx.Constraints.Min}
		}),
	)
}

// renderMenuShell creates a white box with a grey border (used for Popups)
func (r *Renderer) renderMenuShell(gtx layout.Context, content layout.Widget) layout.Dimensions {
	return widget.Border{
		Color:        color.NRGBA{R: 200, G: 200, B: 200, A: 255},
		Width:        unit.Dp(1),
		CornerRadius: unit.Dp(4),
	}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
		return layout.Stack{}.Layout(gtx,
			layout.Expanded(func(gtx layout.Context) layout.Dimensions {
				paint.FillShape(gtx.Ops, color.NRGBA{R: 255, G: 255, B: 255, A: 255}, clip.Rect{Max: gtx.Constraints.Min}.Op())
				return layout.Dimensions{Size: gtx.Constraints.Min}
			}),
			layout.Stacked(content),
		)
	})
}

func formatSize(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}

############################################################
# File: internal/ui/layout.go
############################################################

package ui

import (
	"image"
	"image/color"
	"strings"
	"time"

	"gioui.org/io/event"
	"gioui.org/io/key"
	"gioui.org/io/pointer"
	"gioui.org/layout"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/unit"
	"gioui.org/widget"
	"gioui.org/widget/material"
)

func (r *Renderer) Layout(gtx layout.Context, state *State) UIEvent {
	area := clip.Rect{Max: gtx.Constraints.Max}
	defer area.Push(gtx.Ops).Pop()

	keyTag := &r.listState
	event.Op(gtx.Ops, keyTag)

	if !r.focused {
		gtx.Execute(key.FocusCmd{Tag: keyTag})
		r.focused = true
	}

	// 1. Process Input
	eventOut := r.processGlobalInput(gtx, state)

	// --- VIEW DEFINITIONS ---

	appBar := func(gtx layout.Context) layout.Dimensions {
		return layout.Flex{Axis: layout.Horizontal, Alignment: layout.Middle}.Layout(gtx,
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				if r.fileMenuBtn.Clicked(gtx) {
					r.fileMenuOpen = !r.fileMenuOpen
				}
				btn := material.Button(r.Theme, &r.fileMenuBtn, "File")
				btn.Inset = layout.UniformInset(unit.Dp(6))
				btn.Background = color.NRGBA{}
				btn.Color = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
				return btn.Layout(gtx)
			}),
		)
	}

	navBar := func(gtx layout.Context) layout.Dimensions {
		return layout.Flex{Axis: layout.Horizontal, Alignment: layout.Middle}.Layout(gtx,
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				if r.backBtn.Clicked(gtx) {
					eventOut = UIEvent{Action: ActionBack}
					gtx.Execute(key.FocusCmd{Tag: keyTag})
				}
				return material.Button(r.Theme, &r.backBtn, "<").Layout(gtx)
			}),
			layout.Rigid(layout.Spacer{Width: unit.Dp(4)}.Layout),
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				if r.fwdBtn.Clicked(gtx) {
					eventOut = UIEvent{Action: ActionForward}
					gtx.Execute(key.FocusCmd{Tag: keyTag})
				}
				return material.Button(r.Theme, &r.fwdBtn, ">").Layout(gtx)
			}),
			layout.Rigid(layout.Spacer{Width: unit.Dp(16)}.Layout),
			layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
				if r.isEditing {
					for {
						evt, ok := r.pathEditor.Update(gtx)
						if !ok {
							break
						}
						if s, ok := evt.(widget.SubmitEvent); ok {
							r.isEditing = false
							eventOut = UIEvent{Action: ActionNavigate, Path: strings.TrimSpace(s.Text)}
							gtx.Execute(key.FocusCmd{Tag: keyTag})
						}
					}
					return material.Editor(r.Theme, &r.pathEditor, "Path").Layout(gtx)
				}
				if r.pathClick.Clicked(gtx) {
					r.isEditing = true
					r.pathEditor.SetText(state.CurrentPath)
					gtx.Execute(key.FocusCmd{Tag: &r.pathEditor})
				}
				return material.Clickable(gtx, &r.pathClick, func(gtx layout.Context) layout.Dimensions {
					return material.H6(r.Theme, state.CurrentPath).Layout(gtx)
				})
			}),
			layout.Rigid(layout.Spacer{Width: unit.Dp(16)}.Layout),
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				gtx.Constraints.Min.X = gtx.Dp(unit.Dp(200))
				gtx.Constraints.Max.X = gtx.Dp(unit.Dp(200))
				for {
					evt, ok := r.searchEditor.Update(gtx)
					if !ok {
						break
					}
					if s, ok := evt.(widget.SubmitEvent); ok {
						eventOut = UIEvent{Action: ActionSearch, Path: s.Text}
						gtx.Execute(key.FocusCmd{Tag: keyTag})
					}
				}
				ed := material.Editor(r.Theme, &r.searchEditor, "Search...")
				ed.TextSize = unit.Sp(14)
				border := widget.Border{Color: color.NRGBA{R: 200, G: 200, B: 200, A: 255}, Width: unit.Dp(1), CornerRadius: unit.Dp(4)}
				return border.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
					return layout.Inset{Top: unit.Dp(6), Bottom: unit.Dp(6), Left: unit.Dp(8), Right: unit.Dp(8)}.Layout(gtx, ed.Layout)
				})
			}),
		)
	}

	// Sidebar now mirrors mainList structure exactly
	sidebar := func(gtx layout.Context) layout.Dimensions {
		return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				return layout.Inset{Bottom: unit.Dp(8), Top: unit.Dp(8), Left: unit.Dp(8)}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
					return material.Body2(r.Theme, "FAVORITES").Layout(gtx)
				})
			}),
			layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
				// KEY: Add pointer.PassOp at top level, exactly like mainList does
				defer pointer.PassOp{}.Push(gtx.Ops).Pop()

				return r.favState.Layout(gtx, len(state.FavList), func(gtx layout.Context, index int) layout.Dimensions {
					fav := &state.FavList[index]

					// Handle left-click - check BEFORE renderFavoriteRow, exactly like mainList
					if fav.Clickable.Clicked(gtx) {
						eventOut = UIEvent{Action: ActionNavigate, Path: fav.Path}
					}

					// Handle right-click - check BEFORE renderFavoriteRow, exactly like mainList
					if r.detectRightClick(gtx, &fav.RightClickTag) {
						r.menuVisible = true
						r.menuPos = r.mousePos
						r.menuPath = fav.Path
						r.menuIsDir = true // Favorites are always directories
						r.menuIsFav = true
					}

					return r.renderFavoriteRow(gtx, fav, false)
				})
			}),
		)
	}

	mainList := func(gtx layout.Context) layout.Dimensions {
		defer pointer.PassOp{}.Push(gtx.Ops).Pop()
		if r.Debug {
			paint.FillShape(gtx.Ops, color.NRGBA{R: 240, G: 240, B: 240, A: 255}, clip.Rect{Max: gtx.Constraints.Max}.Op())
		}
		return r.listState.Layout(gtx, len(state.Entries), func(gtx layout.Context, index int) layout.Dimensions {
			item := &state.Entries[index]
			isSelected := index == state.SelectedIndex

			if item.Clickable.Clicked(gtx) {
				if r.isEditing {
					r.isEditing = false
				}
				if r.fileMenuOpen {
					r.fileMenuOpen = false
				}
				eventOut = UIEvent{Action: ActionSelect, NewIndex: index}
				gtx.Execute(key.FocusCmd{Tag: keyTag})
				now := time.Now()
				if !item.LastClick.IsZero() && now.Sub(item.LastClick) < 500*time.Millisecond {
					if item.IsDir {
						eventOut = UIEvent{Action: ActionNavigate, Path: item.Path}
					} else {
						eventOut = UIEvent{Action: ActionOpen, Path: item.Path}
					}
				}
				item.LastClick = now
			}

			// Use shared Right Click helper
			if r.detectRightClick(gtx, &item.RightClickTag) {
				r.menuVisible = true
				r.menuPos = r.mousePos
				r.menuPath = item.Path
				r.menuIsDir = item.IsDir
				_, r.menuIsFav = state.Favorites[item.Path]
				eventOut = UIEvent{Action: ActionSelect, NewIndex: index}
			}

			return r.renderRow(gtx, item, isSelected)
		})
	}

	// 2. Main Layout Stack
	layout.Stack{}.Layout(gtx,
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			if r.bgClick.Clicked(gtx) {
				if r.menuVisible {
					r.menuVisible = false
				}
				if r.fileMenuOpen {
					r.fileMenuOpen = false
				}
				if !r.settingsOpen {
					eventOut = UIEvent{Action: ActionSelect, NewIndex: -1}
					gtx.Execute(key.FocusCmd{Tag: keyTag})
				}
			}
			return r.bgClick.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
				return layout.Dimensions{Size: gtx.Constraints.Max}
			})
		}),
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
				layout.Rigid(func(gtx layout.Context) layout.Dimensions {
					return layout.Inset{Top: unit.Dp(0), Bottom: unit.Dp(0), Left: unit.Dp(8), Right: unit.Dp(8)}.Layout(gtx, appBar)
				}),
				layout.Rigid(func(gtx layout.Context) layout.Dimensions {
					return layout.Inset{Top: unit.Dp(4), Bottom: unit.Dp(8), Left: unit.Dp(8), Right: unit.Dp(8)}.Layout(gtx, navBar)
				}),
				layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
					return layout.Flex{Axis: layout.Horizontal}.Layout(gtx,
						layout.Rigid(func(gtx layout.Context) layout.Dimensions {
							gtx.Constraints.Min.X = gtx.Dp(180)
							gtx.Constraints.Max.X = gtx.Dp(180)
							paint.FillShape(gtx.Ops, color.NRGBA{R: 245, G: 245, B: 245, A: 255}, clip.Rect{Max: gtx.Constraints.Max}.Op())
							return sidebar(gtx)
						}),
						layout.Rigid(func(gtx layout.Context) layout.Dimensions {
							paint.FillShape(gtx.Ops, color.NRGBA{A: 50}, clip.Rect{Max: image.Pt(gtx.Dp(1), gtx.Constraints.Max.Y)}.Op())
							return layout.Dimensions{Size: image.Pt(gtx.Dp(1), gtx.Constraints.Max.Y)}
						}),
						layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
							return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
								layout.Rigid(func(gtx layout.Context) layout.Dimensions {
									return layout.Inset{Top: unit.Dp(4), Bottom: unit.Dp(4), Left: unit.Dp(12), Right: unit.Dp(12)}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
										dims, evt := r.renderColumns(gtx)
										if evt.Action != ActionNone {
											eventOut = evt
										}
										return dims
									})
								}),
								layout.Rigid(func(gtx layout.Context) layout.Dimensions {
									return widget.Border{Color: color.NRGBA{A: 50}, Width: unit.Dp(1)}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
										return layout.Spacer{Height: unit.Dp(1), Width: unit.Dp(1)}.Layout(gtx)
									})
								}),
								layout.Flexed(1, mainList),
							)
						}),
					)
				}),
			)
		}),

		// --- POPUPS & MENUS (Moved to menus.go) ---

		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			// Logic now lives in layoutFileMenu
			dims, evt := r.layoutFileMenu(gtx)
			if evt.Action != ActionNone {
				eventOut = evt
			}
			return dims
		}),

		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			// Logic now lives in layoutContextMenu
			dims, evt := r.layoutContextMenu(gtx)
			if evt.Action != ActionNone {
				eventOut = evt
			}
			return dims
		}),

		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			// Logic now lives in layoutSettingsModal
			return r.layoutSettingsModal(gtx)
		}),
	)

	return eventOut
}

############################################################
# File: internal/ui/menus.go
############################################################

package ui

import (
	"image"
	"image/color"

	"gioui.org/layout"
	"gioui.org/op"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/unit"
	"gioui.org/widget/material"
)

// layoutFileMenu renders the dropdown under the "File" button
func (r *Renderer) layoutFileMenu(gtx layout.Context) (layout.Dimensions, UIEvent) {
	if !r.fileMenuOpen {
		return layout.Dimensions{}, UIEvent{}
	}

	// Positioning offset
	offset := op.Offset(image.Point{X: 8, Y: 30}).Push(gtx.Ops)
	defer offset.Pop()

	return r.renderMenuShell(gtx, func(gtx layout.Context) layout.Dimensions {
		if r.settingsBtn.Clicked(gtx) {
			r.fileMenuOpen = false
			r.settingsOpen = true
		}
		gtx.Constraints.Min.X = gtx.Dp(120)
		return r.renderMenuItem(gtx, &r.settingsBtn, "Settings")
	}), UIEvent{}
}

// layoutContextMenu renders the right-click popup
func (r *Renderer) layoutContextMenu(gtx layout.Context) (layout.Dimensions, UIEvent) {
	if !r.menuVisible {
		return layout.Dimensions{}, UIEvent{}
	}
	var eventOut UIEvent

	offset := op.Offset(r.menuPos).Push(gtx.Ops)
	defer offset.Pop()

	// Handle Button Clicks
	if r.openBtn.Clicked(gtx) {
		r.menuVisible = false
		eventOut = UIEvent{Action: ActionOpen, Path: r.menuPath}
	}
	if r.copyBtn.Clicked(gtx) {
		r.menuVisible = false
	}
	if r.favBtn.Clicked(gtx) {
		r.menuVisible = false
		if r.menuIsFav {
			eventOut = UIEvent{Action: ActionRemoveFavorite, Path: r.menuPath}
		} else {
			eventOut = UIEvent{Action: ActionAddFavorite, Path: r.menuPath}
		}
	}

	dims := r.renderMenuShell(gtx, func(gtx layout.Context) layout.Dimensions {
		gtx.Constraints.Min.X = gtx.Dp(180)
		return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				// Only show "Open" for files, not directories
				if r.menuIsDir {
					return layout.Dimensions{}
				}
				return r.renderMenuItem(gtx, &r.openBtn, "Open")
			}),
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				return r.renderMenuItem(gtx, &r.copyBtn, "Copy (noop)")
			}),
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				if !r.menuIsDir {
					return layout.Dimensions{}
				}
				text := "Add to Favorites"
				if r.menuIsFav {
					text = "Remove Favorite"
				}
				return r.renderMenuItem(gtx, &r.favBtn, text)
			}),
		)
	})

	return dims, eventOut
}

// layoutSettingsModal renders the centered settings dialog
func (r *Renderer) layoutSettingsModal(gtx layout.Context) layout.Dimensions {
	if !r.settingsOpen {
		return layout.Dimensions{}
	}
	if r.settingsCloseBtn.Clicked(gtx) {
		r.settingsOpen = false
	}

	return layout.Stack{}.Layout(gtx,
		// Semi-transparent backdrop
		layout.Expanded(func(gtx layout.Context) layout.Dimensions {
			paint.FillShape(gtx.Ops, color.NRGBA{A: 150}, clip.Rect{Max: gtx.Constraints.Max}.Op())
			return material.Clickable(gtx, &r.settingsCloseBtn, func(gtx layout.Context) layout.Dimensions {
				return layout.Dimensions{Size: gtx.Constraints.Max}
			})
		}),
		// The Dialog
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			return layout.Center.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
				return r.renderMenuShell(gtx, func(gtx layout.Context) layout.Dimensions {
					gtx.Constraints.Min.X = gtx.Dp(300)
					gtx.Constraints.Min.Y = gtx.Dp(200)
					return layout.UniformInset(unit.Dp(20)).Layout(gtx, func(gtx layout.Context) layout.Dimensions {
						return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
							layout.Rigid(func(gtx layout.Context) layout.Dimensions {
								h6 := material.H6(r.Theme, "Settings")
								h6.Color = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
								return h6.Layout(gtx)
							}),
							layout.Rigid(layout.Spacer{Height: unit.Dp(20)}.Layout),
							layout.Rigid(func(gtx layout.Context) layout.Dimensions {
								lbl := material.Body1(r.Theme, "Search Engine:")
								lbl.Color = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
								return lbl.Layout(gtx)
							}),
							layout.Rigid(func(gtx layout.Context) layout.Dimensions {
								return material.RadioButton(r.Theme, &r.searchEngine, "default", "Default").Layout(gtx)
							}),
							layout.Rigid(func(gtx layout.Context) layout.Dimensions {
								return material.RadioButton(r.Theme, &r.searchEngine, "ripgrep", "ripgrep").Layout(gtx)
							}),
						)
					})
				})
			})
		}),
	)
}

############################################################
# File: internal/ui/renderer.go
############################################################

package ui

import (
	"image"
	"image/color"
	"path/filepath"
	"strings"
	"time"

	"gioui.org/font"
	"gioui.org/io/event"
	"gioui.org/io/key"
	"gioui.org/io/pointer"
	"gioui.org/layout"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/text"
	"gioui.org/unit"
	"gioui.org/widget"
	"gioui.org/widget/material"
)

type UIAction int

const (
	ActionNone UIAction = iota
	ActionNavigate
	ActionBack
	ActionForward
	ActionSelect
	ActionSearch
	ActionOpen
	ActionAddFavorite
	ActionRemoveFavorite
	ActionSort
)

type SortColumn int

const (
	SortByName SortColumn = iota
	SortByDate
	SortByType
	SortBySize
)

type UIEvent struct {
	Action        UIAction
	Path          string
	NewIndex      int
	SortColumn    SortColumn
	SortAscending bool
}

type UIEntry struct {
	Name          string
	Path          string
	IsDir         bool
	Size          int64
	ModTime       time.Time
	Clickable     widget.Clickable
	RightClickTag int
	LastClick     time.Time
}

type FavoriteItem struct {
	Name          string
	Path          string
	Clickable     widget.Clickable
	RightClickTag int
}

type State struct {
	CurrentPath   string
	Entries       []UIEntry
	SelectedIndex int
	CanBack       bool
	CanForward    bool
	Favorites     map[string]bool
	FavList       []FavoriteItem
}

type Renderer struct {
	Theme     *material.Theme
	listState layout.List
	favState  layout.List
	backBtn   widget.Clickable
	fwdBtn    widget.Clickable

	bgClick widget.Clickable
	focused bool
	Debug   bool

	pathEditor widget.Editor
	pathClick  widget.Clickable
	isEditing  bool

	searchEditor widget.Editor

	menuVisible bool
	menuPos     image.Point
	menuPath    string
	menuIsDir   bool
	menuIsFav   bool

	openBtn widget.Clickable
	copyBtn widget.Clickable
	favBtn  widget.Clickable

	fileMenuBtn  widget.Clickable
	fileMenuOpen bool
	settingsBtn  widget.Clickable

	settingsOpen     bool
	settingsCloseBtn widget.Clickable
	searchEngine     widget.Enum

	mousePos image.Point
	mouseTag struct{}

	// Column header sorting
	nameHeaderBtn widget.Clickable
	dateHeaderBtn widget.Clickable
	typeHeaderBtn widget.Clickable
	sizeHeaderBtn widget.Clickable
	SortColumn    SortColumn
	SortAscending bool
}

func NewRenderer() *Renderer {
	r := &Renderer{
		Theme: material.NewTheme(),
	}
	r.listState.Axis = layout.Vertical
	r.favState.Axis = layout.Vertical
	r.pathEditor.SingleLine = true
	r.pathEditor.Submit = true

	r.searchEditor.SingleLine = true
	r.searchEditor.Submit = true

	r.searchEngine.Value = "default"

	// Default sort: by name, ascending
	r.SortColumn = SortByName
	r.SortAscending = true

	return r
}

// detectRightClick checks for secondary button presses on a specific tag
func (r *Renderer) detectRightClick(gtx layout.Context, tag event.Tag) bool {
	for {
		ev, ok := gtx.Event(pointer.Filter{Target: tag, Kinds: pointer.Press | pointer.Release})
		if !ok {
			break
		}
		if e, ok := ev.(pointer.Event); ok {
			if e.Kind == pointer.Press && e.Buttons.Contain(pointer.ButtonSecondary) {
				return true
			}
		}
	}
	return false
}

// processGlobalInput handles keyboard shortcuts and global mouse tracking
func (r *Renderer) processGlobalInput(gtx layout.Context, state *State) UIEvent {
	var eventOut UIEvent

	// Mouse Tracking
	mouseTag := &r.mouseTag
	event.Op(gtx.Ops, mouseTag)
	for {
		ev, ok := gtx.Event(pointer.Filter{Target: mouseTag, Kinds: pointer.Move})
		if !ok {
			break
		}
		if x, ok := ev.(pointer.Event); ok {
			r.mousePos = image.Point{X: int(x.Position.X), Y: int(x.Position.Y)}
		}
	}

	// Keyboard Shortcuts
	for {
		e, ok := gtx.Event(key.Filter{Focus: true, Name: ""})
		if !ok {
			break
		}
		if r.isEditing || r.settingsOpen {
			continue
		}
		if k, ok := e.(key.Event); ok && k.State == key.Press {
			switch k.Name {
			case "Up":
				newIndex := -1
				if state.SelectedIndex > 0 {
					newIndex = state.SelectedIndex - 1
				} else if state.SelectedIndex == -1 && len(state.Entries) > 0 {
					newIndex = len(state.Entries) - 1
				}
				if newIndex != -1 {
					eventOut = UIEvent{Action: ActionSelect, NewIndex: newIndex}
					r.listState.ScrollTo(newIndex)
				}
			case "Down":
				newIndex := -1
				if state.SelectedIndex < len(state.Entries)-1 {
					newIndex = state.SelectedIndex + 1
				} else if state.SelectedIndex == -1 && len(state.Entries) > 0 {
					newIndex = 0
				}
				if newIndex != -1 {
					eventOut = UIEvent{Action: ActionSelect, NewIndex: newIndex}
					r.listState.ScrollTo(newIndex)
				}
			case "Left":
				if k.Modifiers.Contain(key.ModAlt) && state.CanBack {
					eventOut = UIEvent{Action: ActionBack}
				}
			case "Right":
				if k.Modifiers.Contain(key.ModAlt) && state.CanForward {
					eventOut = UIEvent{Action: ActionForward}
				}
			case "Return", "Enter":
				if state.SelectedIndex >= 0 && state.SelectedIndex < len(state.Entries) {
					item := state.Entries[state.SelectedIndex]
					if item.IsDir {
						eventOut = UIEvent{Action: ActionNavigate, Path: item.Path}
					} else {
						eventOut = UIEvent{Action: ActionOpen, Path: item.Path}
					}
				}
			}
		}
	}
	return eventOut
}

// getSortIndicator returns the appropriate arrow indicator for a column header
func (r *Renderer) getSortIndicator(column SortColumn) string {
	if r.SortColumn != column {
		return ""
	}
	if r.SortAscending {
		return " ▲"
	}
	return " ▼"
}

// renderColumnHeader creates a clickable column header with sort indicator
func (r *Renderer) renderColumnHeader(gtx layout.Context, btn *widget.Clickable, label string, column SortColumn, alignment text.Alignment) layout.Dimensions {
	// Build the label with sort indicator
	displayLabel := label + r.getSortIndicator(column)

	// Determine text color based on whether this column is sorted
	textColor := color.NRGBA{R: 100, G: 100, B: 100, A: 255}
	fontWeight := font.Normal
	if r.SortColumn == column {
		textColor = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
		fontWeight = font.Medium
	}

	return material.Clickable(gtx, btn, func(gtx layout.Context) layout.Dimensions {
		lbl := material.Body2(r.Theme, displayLabel)
		lbl.Color = textColor
		lbl.Font.Weight = fontWeight
		lbl.Alignment = alignment
		return lbl.Layout(gtx)
	})
}

// --- MAIN LAYOUT ---
func (r *Renderer) renderColumns(gtx layout.Context) (layout.Dimensions, UIEvent) {
	var eventOut UIEvent

	// Handle column header clicks
	if r.nameHeaderBtn.Clicked(gtx) {
		if r.SortColumn == SortByName {
			r.SortAscending = !r.SortAscending
		} else {
			r.SortColumn = SortByName
			r.SortAscending = true
		}
		eventOut = UIEvent{Action: ActionSort, SortColumn: r.SortColumn, SortAscending: r.SortAscending}
	}
	if r.dateHeaderBtn.Clicked(gtx) {
		if r.SortColumn == SortByDate {
			r.SortAscending = !r.SortAscending
		} else {
			r.SortColumn = SortByDate
			r.SortAscending = true
		}
		eventOut = UIEvent{Action: ActionSort, SortColumn: r.SortColumn, SortAscending: r.SortAscending}
	}
	if r.typeHeaderBtn.Clicked(gtx) {
		if r.SortColumn == SortByType {
			r.SortAscending = !r.SortAscending
		} else {
			r.SortColumn = SortByType
			r.SortAscending = true
		}
		eventOut = UIEvent{Action: ActionSort, SortColumn: r.SortColumn, SortAscending: r.SortAscending}
	}
	if r.sizeHeaderBtn.Clicked(gtx) {
		if r.SortColumn == SortBySize {
			r.SortAscending = !r.SortAscending
		} else {
			r.SortColumn = SortBySize
			r.SortAscending = true
		}
		eventOut = UIEvent{Action: ActionSort, SortColumn: r.SortColumn, SortAscending: r.SortAscending}
	}

	dims := layout.Flex{Axis: layout.Horizontal, Spacing: layout.SpaceBetween}.Layout(gtx,
		layout.Flexed(0.5, func(gtx layout.Context) layout.Dimensions {
			return r.renderColumnHeader(gtx, &r.nameHeaderBtn, "Name", SortByName, text.Start)
		}),
		layout.Flexed(0.25, func(gtx layout.Context) layout.Dimensions {
			return r.renderColumnHeader(gtx, &r.dateHeaderBtn, "Date Modified", SortByDate, text.Start)
		}),
		layout.Flexed(0.15, func(gtx layout.Context) layout.Dimensions {
			return r.renderColumnHeader(gtx, &r.typeHeaderBtn, "Type", SortByType, text.Start)
		}),
		layout.Flexed(0.10, func(gtx layout.Context) layout.Dimensions {
			return r.renderColumnHeader(gtx, &r.sizeHeaderBtn, "Size", SortBySize, text.End)
		}),
	)

	return dims, eventOut
}

func (r *Renderer) renderRow(gtx layout.Context, item *UIEntry, selected bool) layout.Dimensions {
	return layout.Stack{}.Layout(gtx,
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			return material.Clickable(gtx, &item.Clickable, func(gtx layout.Context) layout.Dimensions {
				return layout.Stack{}.Layout(gtx,
					layout.Expanded(func(gtx layout.Context) layout.Dimensions {
						if selected {
							paint.FillShape(gtx.Ops, color.NRGBA{R: 200, G: 220, B: 255, A: 255}, clip.Rect{Max: gtx.Constraints.Min}.Op())
						}
						return layout.Dimensions{}
					}),
					layout.Stacked(func(gtx layout.Context) layout.Dimensions {
						name := item.Name
						typeStr := "File"
						sizeStr := formatSize(item.Size)
						dateStr := item.ModTime.Format("01/02/06 03:04 PM")
						textColor := color.NRGBA{R: 0, G: 0, B: 0, A: 255}
						weight := font.Normal

						if item.IsDir {
							name = item.Name + "/"
							typeStr = "File Folder"
							sizeStr = ""
							textColor = color.NRGBA{R: 0, G: 0, B: 128, A: 255}
							weight = font.Bold
						} else {
							ext := filepath.Ext(item.Name)
							if len(ext) > 1 {
								typeStr = strings.ToUpper(ext[1:]) + " File"
							}
						}

						return layout.Inset{
							Top: unit.Dp(8), Bottom: unit.Dp(8), Left: unit.Dp(12), Right: unit.Dp(12),
						}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
							return layout.Flex{Axis: layout.Horizontal, Spacing: layout.SpaceBetween, Alignment: layout.Middle}.Layout(gtx,
								layout.Flexed(0.5, func(gtx layout.Context) layout.Dimensions {
									lbl := material.Body1(r.Theme, name)
									lbl.Color = textColor
									lbl.Font.Weight = weight
									lbl.MaxLines = 1
									return lbl.Layout(gtx)
								}),
								layout.Flexed(0.25, func(gtx layout.Context) layout.Dimensions {
									lbl := material.Body2(r.Theme, dateStr)
									lbl.Color = color.NRGBA{R: 100, G: 100, B: 100, A: 255}
									lbl.MaxLines = 1
									return lbl.Layout(gtx)
								}),
								layout.Flexed(0.15, func(gtx layout.Context) layout.Dimensions {
									lbl := material.Body2(r.Theme, typeStr)
									lbl.Color = color.NRGBA{R: 100, G: 100, B: 100, A: 255}
									lbl.MaxLines = 1
									return lbl.Layout(gtx)
								}),
								layout.Flexed(0.10, func(gtx layout.Context) layout.Dimensions {
									lbl := material.Body2(r.Theme, sizeStr)
									lbl.Color = color.NRGBA{R: 100, G: 100, B: 100, A: 255}
									lbl.Alignment = text.End
									lbl.MaxLines = 1
									return lbl.Layout(gtx)
								}),
							)
						})
					}),
				)
			})
		}),

		layout.Expanded(func(gtx layout.Context) layout.Dimensions {
			defer clip.Rect{Max: gtx.Constraints.Min}.Push(gtx.Ops).Pop()
			event.Op(gtx.Ops, &item.RightClickTag)
			defer pointer.PassOp{}.Push(gtx.Ops).Pop()
			return layout.Dimensions{Size: gtx.Constraints.Min}
		}),
	)
}

