	CREATE TABLE IF NOT EXISTS favorites (
		path TEXT PRIMARY KEY,
		created_at DATETIME DEFAULT CURRENT_TIMESTAMP
	);
	`
	if _, err := db.Exec(query); err != nil {
		return err
	}

	d.conn = db
	return nil
}

func (d *DB) Start() {
	for req := range d.RequestChan {
		switch req.Op {
		case FetchFavorites:
			d.handleFetch()
		case AddFavorite:
			d.handleAdd(req.Path)
		case RemoveFavorite:
			d.handleRemove(req.Path)
		}
	}
}

func (d *DB) handleFetch() {
	rows, err := d.conn.Query("SELECT path FROM favorites ORDER BY created_at ASC")
	if err != nil {
		d.ResponseChan <- Response{Op: FetchFavorites, Err: err}
		return
	}
	defer rows.Close()

	var favs []string
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err == nil {
			favs = append(favs, path)
		}
	}

	d.ResponseChan <- Response{Op: FetchFavorites, Favorites: favs}
}

func (d *DB) handleAdd(path string) {
	// Use INSERT OR IGNORE to handle duplicates gracefully
	_, err := d.conn.Exec("INSERT OR IGNORE INTO favorites (path) VALUES (?)", path)
	if err != nil {
		log.Printf("Store Error: %v", err)
	}
	// Always trigger a fetch after modification to sync UI
	d.handleFetch()
}

func (d *DB) handleRemove(path string) {
	_, err := d.conn.Exec("DELETE FROM favorites WHERE path = ?", path)
	if err != nil {
		log.Printf("Store Error: %v", err)
	}
	d.handleFetch()
}

func (d *DB) Close() {
	if d.conn != nil {
		d.conn.Close()
	}
}


############################################################
# File: internal/ui/components.go
############################################################

package ui

import (
	"fmt"
	"image/color"

	"gioui.org/layout"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/unit"
	"gioui.org/widget"
	"gioui.org/widget/material"
)

// renderMenuItem creates a standard clickable menu row (used in Context Menu, File Menu, Favs)
func (r *Renderer) renderMenuItem(gtx layout.Context, clk *widget.Clickable, text string) layout.Dimensions {
	return material.Clickable(gtx, clk, func(gtx layout.Context) layout.Dimensions {
		return layout.UniformInset(unit.Dp(10)).Layout(gtx, func(gtx layout.Context) layout.Dimensions {
			txt := material.Body2(r.Theme, text)
			txt.Color = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
			return txt.Layout(gtx)
		})
	})
}

// renderMenuShell creates a white box with a grey border (used for Popups)
func (r *Renderer) renderMenuShell(gtx layout.Context, content layout.Widget) layout.Dimensions {
	return widget.Border{
		Color:        color.NRGBA{R: 200, G: 200, B: 200, A: 255},
		Width:        unit.Dp(1),
		CornerRadius: unit.Dp(4),
	}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
		return layout.Stack{}.Layout(gtx,
			layout.Expanded(func(gtx layout.Context) layout.Dimensions {
				paint.FillShape(gtx.Ops, color.NRGBA{R: 255, G: 255, B: 255, A: 255}, clip.Rect{Max: gtx.Constraints.Min}.Op())
				return layout.Dimensions{Size: gtx.Constraints.Min}
			}),
			layout.Stacked(content),
		)
	})
}

func formatSize(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}


############################################################
# File: internal/ui/layout.go
############################################################

package ui

import (
	"image"
	"image/color"
	"strings"
	"time"

	"gioui.org/io/event"
	"gioui.org/io/key"
	"gioui.org/io/pointer"
	"gioui.org/layout"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/unit"
	"gioui.org/widget"
	"gioui.org/widget/material"
)

func (r *Renderer) Layout(gtx layout.Context, state *State) UIEvent {
	area := clip.Rect{Max: gtx.Constraints.Max}
	defer area.Push(gtx.Ops).Pop()

	keyTag := &r.listState
	event.Op(gtx.Ops, keyTag)

	if !r.focused {
		gtx.Execute(key.FocusCmd{Tag: keyTag})
		r.focused = true
	}

	// 1. Process Input
	eventOut := r.processGlobalInput(gtx, state)

	// --- VIEW DEFINITIONS ---

	appBar := func(gtx layout.Context) layout.Dimensions {
		return layout.Flex{Axis: layout.Horizontal, Alignment: layout.Middle}.Layout(gtx,
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				if r.fileMenuBtn.Clicked(gtx) {
					r.fileMenuOpen = !r.fileMenuOpen
				}
				btn := material.Button(r.Theme, &r.fileMenuBtn, "File")
				btn.Inset = layout.UniformInset(unit.Dp(6))
				btn.Background = color.NRGBA{}
				btn.Color = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
				return btn.Layout(gtx)
			}),
		)
	}

	navBar := func(gtx layout.Context) layout.Dimensions {
		return layout.Flex{Axis: layout.Horizontal, Alignment: layout.Middle}.Layout(gtx,
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				if r.backBtn.Clicked(gtx) {
					eventOut = UIEvent{Action: ActionBack}
					gtx.Execute(key.FocusCmd{Tag: keyTag})
				}
				return material.Button(r.Theme, &r.backBtn, "<").Layout(gtx)
			}),
			layout.Rigid(layout.Spacer{Width: unit.Dp(4)}.Layout),
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				if r.fwdBtn.Clicked(gtx) {
					eventOut = UIEvent{Action: ActionForward}
					gtx.Execute(key.FocusCmd{Tag: keyTag})
				}
				return material.Button(r.Theme, &r.fwdBtn, ">").Layout(gtx)
			}),
			layout.Rigid(layout.Spacer{Width: unit.Dp(16)}.Layout),
			layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
				if r.isEditing {
					for {
						evt, ok := r.pathEditor.Update(gtx)
						if !ok {
							break
						}
						if s, ok := evt.(widget.SubmitEvent); ok {
							r.isEditing = false
							eventOut = UIEvent{Action: ActionNavigate, Path: strings.TrimSpace(s.Text)}
							gtx.Execute(key.FocusCmd{Tag: keyTag})
						}
					}
					return material.Editor(r.Theme, &r.pathEditor, "Path").Layout(gtx)
				}
				if r.pathClick.Clicked(gtx) {
					r.isEditing = true
					r.pathEditor.SetText(state.CurrentPath)
					gtx.Execute(key.FocusCmd{Tag: &r.pathEditor})
				}
				return material.Clickable(gtx, &r.pathClick, func(gtx layout.Context) layout.Dimensions {
					return material.H6(r.Theme, state.CurrentPath).Layout(gtx)
				})
			}),
			layout.Rigid(layout.Spacer{Width: unit.Dp(16)}.Layout),
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				gtx.Constraints.Min.X = gtx.Dp(unit.Dp(200))
				gtx.Constraints.Max.X = gtx.Dp(unit.Dp(200))
				for {
					evt, ok := r.searchEditor.Update(gtx)
					if !ok {
						break
					}
					if s, ok := evt.(widget.SubmitEvent); ok {
						eventOut = UIEvent{Action: ActionSearch, Path: s.Text}
						gtx.Execute(key.FocusCmd{Tag: keyTag})
					}
				}
				ed := material.Editor(r.Theme, &r.searchEditor, "Search...")
				ed.TextSize = unit.Sp(14)
				border := widget.Border{Color: color.NRGBA{R: 200, G: 200, B: 200, A: 255}, Width: unit.Dp(1), CornerRadius: unit.Dp(4)}
				return border.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
					return layout.Inset{Top: unit.Dp(6), Bottom: unit.Dp(6), Left: unit.Dp(8), Right: unit.Dp(8)}.Layout(gtx, ed.Layout)
				})
			}),
		)
	}

	sidebar := func(gtx layout.Context) layout.Dimensions {
		return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				return layout.Inset{Bottom: unit.Dp(8), Top: unit.Dp(8), Left: unit.Dp(8)}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
					return material.Body2(r.Theme, "FAVORITES").Layout(gtx)
				})
			}),
			layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
				return r.favState.Layout(gtx, len(state.FavList), func(gtx layout.Context, index int) layout.Dimensions {
					fav := &state.FavList[index]
					if fav.Clickable.Clicked(gtx) {
						eventOut = UIEvent{Action: ActionNavigate, Path: fav.Path}
					}
					// Use shared Right Click helper
					if r.detectRightClick(gtx, &fav.RightClickTag) {
						r.menuVisible = true
						r.menuPos = r.mousePos
						r.menuPath = fav.Path
						r.menuIsFav = true
					}
					// Use shared Menu Item helper
					return r.renderMenuItem(gtx, &fav.Clickable, fav.Name)
				})
			}),
		)
	}

	mainList := func(gtx layout.Context) layout.Dimensions {
		defer pointer.PassOp{}.Push(gtx.Ops).Pop()
		if r.Debug {
			paint.FillShape(gtx.Ops, color.NRGBA{R: 240, G: 240, B: 240, A: 255}, clip.Rect{Max: gtx.Constraints.Max}.Op())
		}
		return r.listState.Layout(gtx, len(state.Entries), func(gtx layout.Context, index int) layout.Dimensions {
			item := &state.Entries[index]
			isSelected := index == state.SelectedIndex

			if item.Clickable.Clicked(gtx) {
				if r.isEditing {
					r.isEditing = false
				}
				if r.fileMenuOpen {
					r.fileMenuOpen = false
				}
				eventOut = UIEvent{Action: ActionSelect, NewIndex: index}
				gtx.Execute(key.FocusCmd{Tag: keyTag})
				now := time.Now()
				if !item.LastClick.IsZero() && now.Sub(item.LastClick) < 500*time.Millisecond {
					if item.IsDir {
						eventOut = UIEvent{Action: ActionNavigate, Path: item.Path}
					} else {
						eventOut = UIEvent{Action: ActionOpen, Path: item.Path}
					}
				}
				item.LastClick = now
			}

			// Use shared Right Click helper
			if r.detectRightClick(gtx, &item.RightClickTag) {
				r.menuVisible = true
				r.menuPos = r.mousePos
				r.menuPath = item.Path
				r.menuIsDir = item.IsDir
				_, r.menuIsFav = state.Favorites[item.Path]
				eventOut = UIEvent{Action: ActionSelect, NewIndex: index}
			}

			return r.renderRow(gtx, item, isSelected)
		})
	}

	// 2. Main Layout Stack
	layout.Stack{}.Layout(gtx,
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			if r.bgClick.Clicked(gtx) {
				if r.menuVisible {
					r.menuVisible = false
				}
				if r.fileMenuOpen {
					r.fileMenuOpen = false
				}
				if !r.settingsOpen {
					eventOut = UIEvent{Action: ActionSelect, NewIndex: -1}
					gtx.Execute(key.FocusCmd{Tag: keyTag})
				}
			}
			return r.bgClick.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
				return layout.Dimensions{Size: gtx.Constraints.Max}
			})
		}),
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
				layout.Rigid(func(gtx layout.Context) layout.Dimensions {
					return layout.Inset{Top: unit.Dp(0), Bottom: unit.Dp(0), Left: unit.Dp(8), Right: unit.Dp(8)}.Layout(gtx, appBar)
				}),
				layout.Rigid(func(gtx layout.Context) layout.Dimensions {
					return layout.Inset{Top: unit.Dp(4), Bottom: unit.Dp(8), Left: unit.Dp(8), Right: unit.Dp(8)}.Layout(gtx, navBar)
				}),
				layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
					return layout.Flex{Axis: layout.Horizontal}.Layout(gtx,
						layout.Rigid(func(gtx layout.Context) layout.Dimensions {
							gtx.Constraints.Min.X = gtx.Dp(180)
							gtx.Constraints.Max.X = gtx.Dp(180)
							paint.FillShape(gtx.Ops, color.NRGBA{R: 245, G: 245, B: 245, A: 255}, clip.Rect{Max: gtx.Constraints.Max}.Op())
							return sidebar(gtx)
						}),
						layout.Rigid(func(gtx layout.Context) layout.Dimensions {
							paint.FillShape(gtx.Ops, color.NRGBA{A: 50}, clip.Rect{Max: image.Pt(gtx.Dp(1), gtx.Constraints.Max.Y)}.Op())
							return layout.Dimensions{Size: image.Pt(gtx.Dp(1), gtx.Constraints.Max.Y)}
						}),
						layout.Flexed(1, func(gtx layout.Context) layout.Dimensions {
							return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
								layout.Rigid(func(gtx layout.Context) layout.Dimensions {
									return layout.Inset{Top: unit.Dp(4), Bottom: unit.Dp(4), Left: unit.Dp(12), Right: unit.Dp(12)}.Layout(gtx, r.renderColumns)
								}),
								layout.Rigid(func(gtx layout.Context) layout.Dimensions {
									return widget.Border{Color: color.NRGBA{A: 50}, Width: unit.Dp(1)}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
										return layout.Spacer{Height: unit.Dp(1), Width: unit.Dp(1)}.Layout(gtx)
									})
								}),
								layout.Flexed(1, mainList),
							)
						}),
					)
				}),
			)
		}),

		// --- POPUPS & MENUS (Moved to menus.go) ---

		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			// Logic now lives in layoutFileMenu
			dims, evt := r.layoutFileMenu(gtx)
			if evt.Action != ActionNone {
				eventOut = evt
			}
			return dims
		}),

		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			// Logic now lives in layoutContextMenu
			dims, evt := r.layoutContextMenu(gtx)
			if evt.Action != ActionNone {
				eventOut = evt
			}
			return dims
		}),

		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			// Logic now lives in layoutSettingsModal
			return r.layoutSettingsModal(gtx)
		}),
	)

	return eventOut
}


############################################################
# File: internal/ui/menus.go
############################################################

package ui

import (
	"image"
	"image/color"

	"gioui.org/layout"
	"gioui.org/op"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/unit"
	"gioui.org/widget/material"
)

// layoutFileMenu renders the dropdown under the "File" button
func (r *Renderer) layoutFileMenu(gtx layout.Context) (layout.Dimensions, UIEvent) {
	if !r.fileMenuOpen {
		return layout.Dimensions{}, UIEvent{}
	}

	// Positioning offset
	offset := op.Offset(image.Point{X: 8, Y: 30}).Push(gtx.Ops)
	defer offset.Pop()

	return r.renderMenuShell(gtx, func(gtx layout.Context) layout.Dimensions {
		if r.settingsBtn.Clicked(gtx) {
			r.fileMenuOpen = false
			r.settingsOpen = true
		}
		gtx.Constraints.Min.X = gtx.Dp(120)
		return r.renderMenuItem(gtx, &r.settingsBtn, "Settings")
	}), UIEvent{}
}

// layoutContextMenu renders the right-click popup
func (r *Renderer) layoutContextMenu(gtx layout.Context) (layout.Dimensions, UIEvent) {
	if !r.menuVisible {
		return layout.Dimensions{}, UIEvent{}
	}
	var eventOut UIEvent

	offset := op.Offset(r.menuPos).Push(gtx.Ops)
	defer offset.Pop()

	// Handle Button Clicks
	if r.openBtn.Clicked(gtx) {
		r.menuVisible = false
		eventOut = UIEvent{Action: ActionOpen, Path: r.menuPath}
	}
	if r.copyBtn.Clicked(gtx) {
		r.menuVisible = false
	}
	if r.favBtn.Clicked(gtx) {
		r.menuVisible = false
		if r.menuIsFav {
			eventOut = UIEvent{Action: ActionRemoveFavorite, Path: r.menuPath}
		} else {
			eventOut = UIEvent{Action: ActionAddFavorite, Path: r.menuPath}
		}
	}

	dims := r.renderMenuShell(gtx, func(gtx layout.Context) layout.Dimensions {
		gtx.Constraints.Min.X = gtx.Dp(180)
		return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				return r.renderMenuItem(gtx, &r.openBtn, "Open")
			}),
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				return r.renderMenuItem(gtx, &r.copyBtn, "Copy (noop)")
			}),
			layout.Rigid(func(gtx layout.Context) layout.Dimensions {
				if !r.menuIsDir {
					return layout.Dimensions{}
				}
				text := "Add to Favorites"
				if r.menuIsFav {
					text = "Remove Favorite"
				}
				return r.renderMenuItem(gtx, &r.favBtn, text)
			}),
		)
	})

	return dims, eventOut
}

// layoutSettingsModal renders the centered settings dialog
func (r *Renderer) layoutSettingsModal(gtx layout.Context) layout.Dimensions {
	if !r.settingsOpen {
		return layout.Dimensions{}
	}
	if r.settingsCloseBtn.Clicked(gtx) {
		r.settingsOpen = false
	}

	return layout.Stack{}.Layout(gtx,
		// Semi-transparent backdrop
		layout.Expanded(func(gtx layout.Context) layout.Dimensions {
			paint.FillShape(gtx.Ops, color.NRGBA{A: 150}, clip.Rect{Max: gtx.Constraints.Max}.Op())
			return material.Clickable(gtx, &r.settingsCloseBtn, func(gtx layout.Context) layout.Dimensions {
				return layout.Dimensions{Size: gtx.Constraints.Max}
			})
		}),
		// The Dialog
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			return layout.Center.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
				return r.renderMenuShell(gtx, func(gtx layout.Context) layout.Dimensions {
					gtx.Constraints.Min.X = gtx.Dp(300)
					gtx.Constraints.Min.Y = gtx.Dp(200)
					return layout.UniformInset(unit.Dp(20)).Layout(gtx, func(gtx layout.Context) layout.Dimensions {
						return layout.Flex{Axis: layout.Vertical}.Layout(gtx,
							layout.Rigid(func(gtx layout.Context) layout.Dimensions {
								h6 := material.H6(r.Theme, "Settings")
								h6.Color = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
								return h6.Layout(gtx)
							}),
							layout.Rigid(layout.Spacer{Height: unit.Dp(20)}.Layout),
							layout.Rigid(func(gtx layout.Context) layout.Dimensions {
								lbl := material.Body1(r.Theme, "Search Engine:")
								lbl.Color = color.NRGBA{R: 0, G: 0, B: 0, A: 255}
								return lbl.Layout(gtx)
							}),
							layout.Rigid(func(gtx layout.Context) layout.Dimensions {
								return material.RadioButton(r.Theme, &r.searchEngine, "default", "Default").Layout(gtx)
							}),
							layout.Rigid(func(gtx layout.Context) layout.Dimensions {
								return material.RadioButton(r.Theme, &r.searchEngine, "ripgrep", "ripgrep").Layout(gtx)
							}),
						)
					})
				})
			})
		}),
	)
}


############################################################
# File: internal/ui/renderer.go
############################################################

package ui

import (
	"image"
	"image/color"
	"path/filepath"
	"strings"
	"time"

	"gioui.org/font"
	"gioui.org/io/event"
	"gioui.org/io/key"
	"gioui.org/io/pointer"
	"gioui.org/layout"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/text"
	"gioui.org/unit"
	"gioui.org/widget"
	"gioui.org/widget/material"
)

type UIAction int

const (
	ActionNone UIAction = iota
	ActionNavigate
	ActionBack
	ActionForward
	ActionSelect
	ActionSearch
	ActionOpen
	ActionAddFavorite
	ActionRemoveFavorite
)

type UIEvent struct {
	Action   UIAction
	Path     string
	NewIndex int
}

type UIEntry struct {
	Name          string
	Path          string
	IsDir         bool
	Size          int64
	ModTime       time.Time
	Clickable     widget.Clickable
	RightClickTag int
	LastClick     time.Time
}

type FavoriteItem struct {
	Name          string
	Path          string
	Clickable     widget.Clickable
	RightClickTag int
}

type State struct {
	CurrentPath   string
	Entries       []UIEntry
	SelectedIndex int
	CanBack       bool
	CanForward    bool
	Favorites     map[string]bool
	FavList       []FavoriteItem
}

type Renderer struct {
	Theme     *material.Theme
	listState layout.List
	favState  layout.List
	backBtn   widget.Clickable
	fwdBtn    widget.Clickable

	bgClick widget.Clickable
	focused bool
	Debug   bool

	pathEditor widget.Editor
	pathClick  widget.Clickable
	isEditing  bool

	searchEditor widget.Editor

	menuVisible bool
	menuPos     image.Point
	menuPath    string
	menuIsDir   bool
	menuIsFav   bool

	openBtn widget.Clickable
	copyBtn widget.Clickable
	favBtn  widget.Clickable

	fileMenuBtn  widget.Clickable
	fileMenuOpen bool
	settingsBtn  widget.Clickable

	settingsOpen     bool
	settingsCloseBtn widget.Clickable
	searchEngine     widget.Enum

	mousePos image.Point
	mouseTag struct{}
}

func NewRenderer() *Renderer {
	r := &Renderer{
		Theme: material.NewTheme(),
	}
	r.listState.Axis = layout.Vertical
	r.favState.Axis = layout.Vertical
	r.pathEditor.SingleLine = true
	r.pathEditor.Submit = true

	r.searchEditor.SingleLine = true
	r.searchEditor.Submit = true

	r.searchEngine.Value = "default"

	return r
}

// detectRightClick checks for secondary button presses on a specific tag
func (r *Renderer) detectRightClick(gtx layout.Context, tag event.Tag) bool {
	for {
		ev, ok := gtx.Event(pointer.Filter{Target: tag, Kinds: pointer.Press | pointer.Release})
		if !ok {
			break
		}
		if e, ok := ev.(pointer.Event); ok {
			if e.Kind == pointer.Press && e.Buttons.Contain(pointer.ButtonSecondary) {
				return true
			}
		}
	}
	return false
}

// processGlobalInput handles keyboard shortcuts and global mouse tracking
func (r *Renderer) processGlobalInput(gtx layout.Context, state *State) UIEvent {
	var eventOut UIEvent

	// Mouse Tracking
	mouseTag := &r.mouseTag
	event.Op(gtx.Ops, mouseTag)
	for {
		ev, ok := gtx.Event(pointer.Filter{Target: mouseTag, Kinds: pointer.Move})
		if !ok {
			break
		}
		if x, ok := ev.(pointer.Event); ok {
			r.mousePos = image.Point{X: int(x.Position.X), Y: int(x.Position.Y)}
		}
	}

	// Keyboard Shortcuts
	for {
		e, ok := gtx.Event(key.Filter{Focus: true, Name: ""})
		if !ok {
			break
		}
		if r.isEditing || r.settingsOpen {
			continue
		}
		if k, ok := e.(key.Event); ok && k.State == key.Press {
			switch k.Name {
			case "Up":
				newIndex := -1
				if state.SelectedIndex > 0 {
					newIndex = state.SelectedIndex - 1
				} else if state.SelectedIndex == -1 && len(state.Entries) > 0 {
					newIndex = len(state.Entries) - 1
				}
				if newIndex != -1 {
					eventOut = UIEvent{Action: ActionSelect, NewIndex: newIndex}
					r.listState.ScrollTo(newIndex)
				}
			case "Down":
				newIndex := -1
				if state.SelectedIndex < len(state.Entries)-1 {
					newIndex = state.SelectedIndex + 1
				} else if state.SelectedIndex == -1 && len(state.Entries) > 0 {
					newIndex = 0
				}
				if newIndex != -1 {
					eventOut = UIEvent{Action: ActionSelect, NewIndex: newIndex}
					r.listState.ScrollTo(newIndex)
				}
			case "Left":
				if k.Modifiers.Contain(key.ModAlt) && state.CanBack {
					eventOut = UIEvent{Action: ActionBack}
				}
			case "Right":
				if k.Modifiers.Contain(key.ModAlt) && state.CanForward {
					eventOut = UIEvent{Action: ActionForward}
				}
			case "Return", "Enter":
				if state.SelectedIndex >= 0 && state.SelectedIndex < len(state.Entries) {
					item := state.Entries[state.SelectedIndex]
					if item.IsDir {
						eventOut = UIEvent{Action: ActionNavigate, Path: item.Path}
					} else {
						eventOut = UIEvent{Action: ActionOpen, Path: item.Path}
					}
				}
			}
		}
	}
	return eventOut
}

// --- MAIN LAYOUT ---
func (r *Renderer) renderColumns(gtx layout.Context) layout.Dimensions {
	return layout.Flex{Axis: layout.Horizontal, Spacing: layout.SpaceBetween}.Layout(gtx,
		layout.Flexed(0.5, func(gtx layout.Context) layout.Dimensions {
			return material.Body2(r.Theme, "Name").Layout(gtx)
		}),
		layout.Flexed(0.25, func(gtx layout.Context) layout.Dimensions {
			return material.Body2(r.Theme, "Date Modified").Layout(gtx)
		}),
		layout.Flexed(0.15, func(gtx layout.Context) layout.Dimensions {
			return material.Body2(r.Theme, "Type").Layout(gtx)
		}),
		layout.Flexed(0.10, func(gtx layout.Context) layout.Dimensions {
			lbl := material.Body2(r.Theme, "Size")
			lbl.Alignment = text.End
			return lbl.Layout(gtx)
		}),
	)
}

func (r *Renderer) renderRow(gtx layout.Context, item *UIEntry, selected bool) layout.Dimensions {
	return layout.Stack{}.Layout(gtx,
		layout.Stacked(func(gtx layout.Context) layout.Dimensions {
			return material.Clickable(gtx, &item.Clickable, func(gtx layout.Context) layout.Dimensions {
				return layout.Stack{}.Layout(gtx,
					layout.Expanded(func(gtx layout.Context) layout.Dimensions {
						if selected {
							paint.FillShape(gtx.Ops, color.NRGBA{R: 200, G: 220, B: 255, A: 255}, clip.Rect{Max: gtx.Constraints.Min}.Op())
						}
						return layout.Dimensions{}
					}),
					layout.Stacked(func(gtx layout.Context) layout.Dimensions {
						name := item.Name
						typeStr := "File"
						sizeStr := formatSize(item.Size)
						dateStr := item.ModTime.Format("01/02/06 03:04 PM")
						textColor := color.NRGBA{R: 0, G: 0, B: 0, A: 255}
						weight := font.Normal

						if item.IsDir {
							name = item.Name + "/"
							typeStr = "File Folder"
							sizeStr = ""
							textColor = color.NRGBA{R: 0, G: 0, B: 128, A: 255}
							weight = font.Bold
						} else {
							ext := filepath.Ext(item.Name)
							if len(ext) > 1 {
								typeStr = strings.ToUpper(ext[1:]) + " File"
							}
						}

						return layout.Inset{
							Top: unit.Dp(8), Bottom: unit.Dp(8), Left: unit.Dp(12), Right: unit.Dp(12),
						}.Layout(gtx, func(gtx layout.Context) layout.Dimensions {
							return layout.Flex{Axis: layout.Horizontal, Spacing: layout.SpaceBetween, Alignment: layout.Middle}.Layout(gtx,
								layout.Flexed(0.5, func(gtx layout.Context) layout.Dimensions {
									lbl := material.Body1(r.Theme, name)
									lbl.Color = textColor
									lbl.Font.Weight = weight
									lbl.MaxLines = 1
									return lbl.Layout(gtx)
								}),
								layout.Flexed(0.25, func(gtx layout.Context) layout.Dimensions {
									lbl := material.Body2(r.Theme, dateStr)
									lbl.Color = color.NRGBA{R: 100, G: 100, B: 100, A: 255}
									lbl.MaxLines = 1
									return lbl.Layout(gtx)
								}),
								layout.Flexed(0.15, func(gtx layout.Context) layout.Dimensions {
									lbl := material.Body2(r.Theme, typeStr)
									lbl.Color = color.NRGBA{R: 100, G: 100, B: 100, A: 255}
									lbl.MaxLines = 1
									return lbl.Layout(gtx)
								}),
								layout.Flexed(0.10, func(gtx layout.Context) layout.Dimensions {
									lbl := material.Body2(r.Theme, sizeStr)
									lbl.Color = color.NRGBA{R: 100, G: 100, B: 100, A: 255}
									lbl.Alignment = text.End
									lbl.MaxLines = 1
									return lbl.Layout(gtx)
								}),
							)
						})
					}),
				)
			})
		}),

		layout.Expanded(func(gtx layout.Context) layout.Dimensions {
			defer clip.Rect{Max: gtx.Constraints.Min}.Push(gtx.Ops).Pop()
			event.Op(gtx.Ops, &item.RightClickTag)
			defer pointer.PassOp{}.Push(gtx.Ops).Pop()
			return layout.Dimensions{Size: gtx.Constraints.Min}
		}),
	)
}


